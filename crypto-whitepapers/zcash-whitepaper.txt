Zerocash: Decentralized Anonymous Payments from Bitcoin
(extended version)
Eli Ben-Sasson∗

Alessandro Chiesa†

Ian Miers‡

Christina Garman‡

Eran Tromer§

Matthew Green‡

Madars Virza†

May 18, 2014

Abstract
Bitcoin is the first digital currency to see widespread adoption. Although payments are
conducted between pseudonyms, Bitcoin cannot offer strong privacy guarantees: payment
transactions are recorded in a public decentralized ledger, from which much information can
be deduced. Zerocoin (Miers et al., IEEE S&P 2013) tackles some of these privacy issues by
unlinking transactions from the payment’s origin. Yet it still reveals payment destinations and
amounts, and is limited in functionality.
In this paper, we construct a full-fledged ledger-based digital currency with strong privacy
guarantees. Our results leverage recent advances in zero-knowledge Succinct Non-interactive
ARguments of Knowledge (zk-SNARKs).
We formulate and construct decentralized anonymous payment schemes (DAP schemes). A
DAP scheme lets users pay each other directly and privately: the corresponding transaction
hides the payment’s origin, destination, and amount. We provide formal definitions and proofs
of the construction’s security.
We then build Zerocash, a practical instantiation of our DAP scheme construction. In
Zerocash, transactions are less than 1 kB and take under 6 ms to verify — orders of magnitude
more efficient than the less-anonymous Zerocoin and competitive with plain Bitcoin.

Keywords: Bitcoin, decentralized electronic cash, zero-knowledge proofs

∗

Technion, eli@cs.technion.ac.il
MIT, {alexch, madars}@mit.edu
‡
Johns Hopkins University, {cgarman, imiers, mgreen}@cs.jhu.edu
§
Tel Aviv University, tromer@cs.tau.ac.il

†

1

Contents
1 Introduction
1.1 zk-SNARKs . . . . . . . . . . . . . . . . . .
1.2 Centralized anonymous payment systems .
1.3 Decentralized anonymous payment schemes
1.4 Zerocash . . . . . . . . . . . . . . . . . . . .
1.5 Paper organization . . . . . . . . . . . . . .

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

3
4
5
5
9
10

2 Background on zk-SNARKs
2.1 Informal definition . . . . . . . . .
2.2 Comparison with NIZKs . . . . . .
2.3 Known constructions and security
2.4 zk-SNARK implementations . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

10
10
11
12
12

3 Definition of a decentralized anonymous payment scheme
3.1 Data structures . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

13
13
14
16
16

4 Construction of a decentralized anonymous payment scheme
4.1 Cryptographic building blocks . . . . . . . . . . . . . . . . . . . .
4.2 zk-SNARKs for pouring coins . . . . . . . . . . . . . . . . . . . .
4.3 Algorithm constructions . . . . . . . . . . . . . . . . . . . . . . .
4.4 Completeness and security . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

18
18
19
20
20

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

5 Zerocash
20
5.1 Instantiation of building blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
5.2 Arithmetic circuit for pouring coins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
6 Integration with existing ledger-based currencies
6.1 Integration by replacing the base currency . . . . . . . .
6.2 Integration by hybrid currency . . . . . . . . . . . . . .
6.3 Extending the Bitcoin protocol to support the combined
6.4 Additional anonymity considerations . . . . . . . . . . .

. . . . . .
. . . . . .
semantics
. . . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

26
26
26
28
28

7 Experiments
28
7.1 Performance of zk-SNARKs for pouring coins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
7.2 Performance of Zerocash algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
7.3 Large-scale network simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
8 Optimizations and extensions
33
8.1 Everlasting anonymity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
8.2 Fast block propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
8.3 Improved storage requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
9 Concurrent work

36

10 Conclusion

36

Acknowledgments

37

A Overview of Bitcoin and Zerocoin
38
A.1 Bitcoin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
A.2 Zerocoin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
B Completeness of DAP schemes

39

C Security of DAP schemes
40
C.1 Ledger indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
C.2 Transaction non-malleability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
C.3 Balance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
D Proof of Theorem 4.1
44
D.1 Proof of ledger indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
D.2 Proof of transaction non-malleability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
D.3 Proof of balance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
References

54

2

1

Introduction

Bitcoin is the first digital currency to achieve widespread adoption. The currency owes its rise
in part to the fact that, unlike traditional e-cash schemes [Cha82, CHL05, ST99], it requires no
trusted parties. Instead of appointing a central bank, Bitcoin uses a distributed ledger known as the
block chain to store transactions carried out between users. Because the block chain is massively
replicated by mutually-distrustful peers, the information it contains is public.
While users may employ many identities (or pseudonyms) to enhance their privacy, an increasing
body of research shows that anyone can de-anonymize Bitcoin by using information in the block
chain [RM11, BBSU12, RS12, MPJ+ 13], such as the structure of the transaction graph as well as
the value and dates of transactions. As a result, Bitcoin fails to offer even a modicum of the privacy
provided by traditional payment systems, let alone the robust privacy of anonymous e-cash schemes.
While Bitcoin is not anonymous itself, those with sufficient motivation can obfuscate their
transaction history with the help of mixes (also known as laundries or tumblers). A mix allows
users to entrust a set of coins to a pool operated by a central party and then, after some interval,
retrieve different coins (with the same total value) from the pool. However, mixes suffer from
three limitations: (i) the delay to reclaim coins must be large to allow enough coins to be mixed
in; (ii) the mix operator can trace coins; and (iii) the mix operator may steal coins.1 For users
with “something to hide”, these risks may be acceptable. But typical legitimate users (1) wish to
keep their spending habits private from their peers, (2) are risk-averse and do not wish to expend
continual effort in protecting their privacy, and (3) are often not sufficiently aware that their privacy
has been compromised.
To protect their privacy, users thus need an instant, risk-free, and, most importantly, automatic
guarantee that data revealing their spending habits and account balances is not publicly accessible
by their neighbors, co-workers, and the merchants with whom they do business. Anonymous
transactions also ensure that the market value of a coin is independent of its history, thus ensuring
that legitimate users’ coins remain fungible.2
Zerocoin: a decentralized mix. Miers et al. [MGGR13] proposed Zerocoin, which extends
Bitcoin to provide strong anonymity guarantees. Like many e-cash protocols (e.g., [CHL05]),
Zerocoin employs zero-knowledge proofs to prevent transaction graph analyses. Unlike earlier
practical e-cash protocols, however, Zerocoin does not rely on digital signatures to validate coins,
nor does it require a central bank to prevent double spending. Instead, Zerocoin authenticates
coins by proving, in zero-knowledge, that they belong to a public list of valid coins (which can be
maintained on the block chain). Yet rather than a full-fledged anonymous currency, Zerocoin is
a decentralized mix, where users may periodically “wash” their bitcoins via the Zerocoin protocol.
Routine day-to-day transactions must be conducted via Bitcoin, due to reasons that we now review.
The first reason is performance. Redeeming zerocoins requires double-discrete-logarithm proofs
of knowledge, which have size that exceeds 45 kB and require 450 ms to verify (at the 128-bit
security level).3 These proofs must be broadcast through the network, verified by every node, and
permanently stored in the ledger. The entailed costs are higher, by orders of magnitude, than those
in Bitcoin and can seriously tax a Bitcoin network operating at normal scale.
1
CoinJoin [Max13], an alternative proposal, replaces the central party of a mix with multi-signature transactions
that involve many collaborating Bitcoin users. CoinJoin can thus only mix small volumes of coins amongst users who
are currently online, is prone to denial-of-service attacks by third parties, and requires effort to find mixing partners.
2
While the methods we detail in this paper accomplish this, the same techniques open the door for privacy-preserving
accountability and oversight (see Section 10).
3
These published numbers [MGGR13] actually use a mix of parameters at both 128-bit and 80-bit security for
different components of the construction. The cost is higher if all parameters are instantiated at 128-bit security.

3

The second reason is functionality. While Zerocoin constitutes a basic e-cash scheme, it lacks
critical features required of full-fledged anonymous payments. First, Zerocoin uses coins of fixed
denomination: it does not support payments of exact values, nor does it provide a means to give
change following a transaction (i.e., divide coins). Second, Zerocoin has no mechanism for one
user to pay another one directly in “zerocoins”. And third, while Zerocoin provides anonymity
by unlinking a payment transaction from its origin address, it does not hide the amount or other
metadata about transactions occurring on the network.
Our contribution. Addressing this challenge, this work offers two main contributions.
(1) We introduce the notion of a decentralized anonymous payment scheme, which formally captures
the functionality and security guarantees of a full-fledged decentralized electronic currency with
strong anonymity guarantees. We provide a construction of this primitive and prove its security
under specific cryptographic assumptions. The construction leverages recent advances in the area of
zero-knowledge proofs. Specifically, it uses zero-knowledge Succinct Non-interactive ARguments of
Knowledge (zk-SNARKs) [Gro10, Lip12, BCI+ 13, GGPR13, PGHR13, BCG+ 13, Lip13, BCTV14].
(2) We implement the above primitive, via a system that we call Zerocash. Our system (at 128
bits of security):
• reduces the size of transactions spending a coin to under 1 kB (an improvement of over 97.7%);
• reduces the spend-transaction verification time to under 6 ms (an improvement of over 98.6%);
• allows for anonymous transactions of variable amounts;
• hides transaction amounts and the values of coins held by users; and
• allows for payments to be made directly to a user’s fixed address (without user interaction).
To validate our system, we measured its performance and established feasibility by conducting
1
experiments in a test network of 1000 nodes (approximately 16
of the unique IPs in the Bitcoin
1
network and 3 of the nodes reachable at any given time [DW13]). This inspires confidence that
Zerocash can be deployed as a fork of Bitcoin and operate at the same scale. Thus, due to its
substantially improved functionality and performance, Zerocash makes it possible to entirely replace
traditional Bitcoin payments with anonymous alternatives.
Concurrent work. The idea of using zk-SNARKs in the Bitcoin setting was first presented by one
of the authors at Bitcoin 2013 [Ben13]. In concurrent work, Danezis et al. [DFKP13] suggest using
zk-SNARKs to reduce proof size and verification time in Zerocoin; see Section 9 for a comparison.

1.1

zk-SNARKs

A zk-SNARK is an efficient variant of a zero-knowledge proof of knowledge [GMR89], which we first
informally describe via an example. Suppose Alice wishes to prove to Bob the statement “I (Alice)
own 30 bitcoins”. A simple method for Alice to do so is to point to 30 coins on the block chain and,
for each of them, sign a message (“hello, world”) using the secret key that controls that coin. Alas,
this method leaks knowledge to Bob, by identifying which coins are Alice’s. A zero-knowledge proof
of knowledge allows Alice to achieve the same goal, while revealing no information to Bob (beyond
the fact that she knows some secret keys that control 30 coins). Crucially, such proofs can be
obtained for any statement that can be verified to be true by use of an efficient computation involving
auxiliary inputs such as trapdoors and passwords (such statements are called “NP statements”).
We now sketch in more technical terms the definition of a zk-SNARK; see Section 2 for more
details. A zk-SNARK is a non-interactive zero-knowledge proof of knowledge that is succinct, i.e.,
for which proofs are very short and easy to verify. More precisely, let L be an NP language, and let
C be a nondeterministic decision circuit for L on a given instance size n. A zk-SNARK can be used

4

to prove and verify membership in L, for instances of size n, as follows. After taking C as input, a
trusted party conducts a one-time setup phase that results in two public keys: a proving key pk
and a verification key vk. The proving key pk enables any (untrusted) prover to produce a proof π
attesting to the fact that x ∈ L, for an instance x (of size n) of his choice. The non-interactive proof
π is zero knowledge and a proof of knowledge. Anyone can use the verification key vk to verify the
proof π; in particular zk-SNARK proofs are publicly verifiable: anyone can verify π, without ever
having to interact with the prover who generated π. Succinctness requires that (for a given security
level) π has constant size and can be verified in time that is linear in |x| (rather than linear in |C|).

1.2

Centralized anonymous payment systems

Before describing our new decentralized payment system, we put it in context by recalling two
pre-Bitcoin payment schemes, both of which relied on a bank, acting as a central trusted party.
Anonymous e-cash. Chaum [Cha82] first obtained anonymous e-cash. In Chaum’s scheme, the
minting of a coin involves both a user, Alice, and the bank: to mint a coin of a given value v, Alice
first selects a random secret serial number sn (unknown to the bank); then, the bank, after deducting
v from Alice’s balance, signs sn via a blind signature. Afterwards, if Alice wants to transfer her coin
to Bob, she reveals sn to him and proves that sn was signed by the bank; during this transfer, Bob
(or the bank) cannot deduce Alice’s identity from the revealed information. Double-spending is
prevented because the bank will not honor a coin with a previously-seen serial number.
Unforgeable e-cash. One problem with Chaum’s scheme is that coins can be forged if the bank’s
secret key is compromised. Sander and Ta-Shma [ST99] addressed this, as follows. The bank
maintains a public Merkle tree of “coin commitments”, and users periodically retrieve its root rt; in
particular, the bank maintains no secrets. When Alice requests a coin (of unit value), she picks
a random serial number sn and auxiliary string r, and then sends cm := CRH(snkr) to the bank,
where CRH is a collision-resistant hash; the bank deducts the appropriate amount from Alice’s
balance and then records cm as a leaf in the Merkle tree. Afterwards, to pay Bob, Alice sends him
sn along with a zero-knowledge proof of knowledge π of the following NP statement: “there exists
r such that CRH(snkr) is a leaf in a Merkle tree with root rt”. In other words, Alice can convince
Bob that sn is the serial number contained in some coin commitment in the Merkle tree; but the
zero-knowledge property prevents Bob from learning information about which coin commitment is
Alice’s, thereby protecting Alice’s identity. Later, Bob can “cash out” Alice’s coin by showing sn
and π to the bank.4
Moving to a fungible anonymous decentralized system. In this paper, like [ST99], we
hash a coin’s serial number and use Merkle trees to compactly represent the set of minted coins.
Unlike [ST99], we also ensure the privacy of a coin’s value and support transactions that split and
merge coins, thus achieving (and implementing) a new kind of fully-fungible and divisible payment
scheme. As in Bitcoin (and in stark contrast to previous e-cash schemes), we do not rely on a
trusted bank. Therefore, we require a new set of definitions and protocols, designed to protect
Alice’s anonymity while preventing her from falsely increasing her balance under the veil of her
boosted privacy. An informal description of our payment scheme follows.

1.3

Decentralized anonymous payment schemes

We construct a decentralized anonymous payment (DAP) scheme, which is a decentralized e-cash
scheme that allows direct anonymous payments of any amount. See Section 3 for a formal definition.
4

We omit details about how the bank can identify Alice in the event that she double spends her coin.

5

Here, we outline our construction in six incremental steps; the construction details are in Section 4.
Our construction functions on top of any ledger-based base currency, such as Bitcoin. At any
given time, a unique valid snapshot of the currency’s ledger is available to all users. The ledger is a
sequence of transactions and is append-only. Transactions include both the underlying currency’s
transactions, as well as new transactions introduced by our construction. For concreteness, we focus
the discussion below on Bitcoin (though later definitions and constructions are stated abstractly). We
assume familiarity with Bitcoin [Nak09] and Zerocoin [MGGR13]; both are reviewed in Appendix A.
Step 1: user anonymity with fixed-value coins. We first describe a simplified construction,
in which all coins have the same value of, e.g., 1 BTC. This construction, similar to the Zerocoin
protocol, shows how to hide a payment’s origin. In terms of tools, we make use of zk-SNARKs
(recalled above) and a commitment scheme. Let COMM denote a statistically-hiding non-interactive
commitment scheme (i.e., given randomness r and message m, the commitment is c := COMMr (m);
subsequently, c is opened by revealing r and m, and one can verify that COMMr (m) equals c).
In the simplified construction, a new coin c is minted as follows: a user u samples a random
serial number sn and a trapdoor r, computes a coin commitment cm := COMMr (sn), and sets
c := (r, sn, cm). A corresponding mint transaction txMint , containing cm (but not sn or r), is sent to
the ledger; txMint is appended to the ledger only if u has paid 1 BTC to a backing escrow pool (e.g.,
the 1 BTC may be paid via plaintext information encoded in txMint ). Mint transactions are thus
certificates of deposit, deriving their value from the backing pool.
Subsequently, letting CMList denote the list of all coin commitments on the ledger, u may spend
c by posting a spend transaction txSpend that contains (i) the coin’s serial number sn; and (ii) a
zk-SNARK proof π of the NP statement “I know r such that COMMr (sn) appears in the list CMList
of coin commitments”. Assuming that sn does not already appear on the ledger (as part of a past
spend transaction), u can redeem the deposited amount of 1 BTC, which u can either keep, transfer
to someone else, or mint a new coin. (If sn does already appear on the ledger, this is considered
double spending, and the transaction is discarded.)
User anonymity is achieved because the proof π is zero-knowledge: while sn is revealed, no
information about r is, and finding which of the numerous commitments in CMList corresponds
to a particular spend transaction txSpend is equivalent to inverting f (x) := COMMx (sn), which is
assumed to be infeasible. Thus, the origin of the payment is anonymous.
Step 2: compressing the list of coin commitments. In the above NP statement, CMList is
specified explicitly as a list of coin commitments. This naive representation severely limits scalability
because the time and space complexity of most protocol algorithms (e.g., the proof verification
algorithm) grow linearly with CMList. Moreover, coin commitments corresponding to already-spent
coins cannot be dropped from CMList to reduce costs, since they cannot be identified (due to the
same zero-knowledge property that provides anonymity).
As in [ST99], we rely on a collision-resistant function CRH to avoid an explicit representation
of CMList. We maintain an efficiently-updatable append-only CRH-based Merkle tree Tree(CMList)
over the (growing) list CMList and let rt denote the root of Tree(CMList). It is well-known that rt
can be updated to account for the insertion of new leaves with time and space proportional to just
the tree depth. Hence, the time and space complexity is reduced from linear in the size of CMList to
logarithmic. With this in mind, we modify the NP statement to the following one: “I know r such
that COMMr (sn) appears as a leaf in a CRH-based Merkle tree whose root is rt”. Compared with
the naive data structure for CMList, this modification increases exponentially the size of CMList
that a given zk-SNARK implementation can support. (Concretely: using Merkle trees of depth 64,
Zerocash supports 264 coins.)
Step 3: extending coins for direct anonymous payments.
6

So far, the coin commitment

cm of a coin c is a commitment to the coin’s serial number sn. However, this creates a problem
when transferring c to another user. Indeed, suppose that a user uA created c, and uA sends c to
another user uB . First, since uA knows sn, the spending of c by uB is both non-anonymous (since
uA sees when c is spent, by recognizing sn) and risky (since uA could still spend c first). Thus, uB
must immediately spend c and mint a new coin c0 to protect himself. Second, if uA in fact wants
to transfer to uB , e.g., 100 BTC, then doing so is both unwieldy (since it requires 100 transfers)
and non-anonymous (since the amount of the transfer is leaked). And third, transfers in amounts
that are not multiples of 1 BTC (the fixed value of a coin) are not supported. Thus, the simplified
construction described is inadequate as a payment scheme.
We address this by modifying the derivation of a coin commitment, and using pseudorandom
functions to target payments and to derive serial numbers, as follows. We use three pseudorandom
functions (derived from a single one). For a seed x, these are denoted PRFaddr
(·), PRFsn
x
x (·), and
sn
PRFpk
(·).
We
assume
that
PRF
is
moreover
collision-resistant.
x
To provide targets for payments, we use addresses: each user u generates an address key pair
(apk , ask ), the address public key and address private key respectively. The coins of u contain the
value apk and can be spent only with knowledge of ask . A key pair (apk , ask ) is sampled by selecting
a random seed ask and setting apk := PRFaddr
ask (0). A user can generate and use any number of
address key pairs.
Next, we redesign minting to allow for greater functionality. To mint a coin c of a desired
value v, the user u first samples ρ, which is a secret value that determines the coin’s serial number
as sn := PRFsn
ask (ρ). Then, u commits to the tuple (apk , v, ρ) in two phases: (a) u computes
k := COMMr (apk kρ) for a random r; and then (b) u computes cm := COMMs (vkk) for a random s.
The minting results in a coin c := (apk , v, ρ, r, s, cm) and a mint transaction txMint := (v, k, s, cm).
Crucially, due to the nested commitment, anyone can verify that cm in txMint is a coin commitment
of a coin of value v (by checking that COMMs (vkk) equals cm) but cannot discern the owner (by
learning the address key apk ) or serial number (derived from ρ) because these are hidden in k. As
before, txMint is accepted by the ledger only if u deposits the correct amount, in this case v BTC.
Coins are spent using the pour operation, which takes a set of input coins, to be consumed, and
“pours” their value into a set of fresh output coins — such that the total value of output coins equals
old
the total value of the input coins. Suppose that u, with address key pair (aold
pk , ask ), wishes to consume
old old old old
old
new and cnew , with total
his coin cold = (aold
2
pk , v , ρ , r , s , cm ) and produce two new coins c1
new . (The addresses
value v1new + v2new = v old , respectively targeted at address public keys anew
and
a
pk,1
pk,2
new
anew
pk,1 and apk,2 may belong to u or to some other user.) The user u, for each i ∈ {1, 2}, proceeds as
new := COMM new (anew kρnew )
follows: (i) u samples serial number randomness ρnew
ri
i ; (ii) u computes ki
pk,i i
new
new
new
new
for a random ri ; and (iii) u computes cmi := COMMsnew
(v
kk
)
for
a
random
snew
i
i
i .
i
new new new new
new
new := (anew , v new , ρnew ,
This yields the coins cnew
:= (anew
1
2
pk,1 , v1 , ρ1 , r1 , s1 , cm1 ) and c2
pk,2 2
new
new
new
r2 , s2 , cm2 ). Next, u produces a zk-SNARK proof πPOUR for the following NP statement, which
we call POUR:
new
“Given the Merkle-tree root rt, serial number snold , and coin commitments cmnew
1 , cm2 , I
old
new
new
old
know coins c , c1 , c2 , and address secret key ask such that:
old
old =
• The coins are well-formed: for cold it holds that k old = COMMrold (aold
pk kρ ) and cm
COMMsold (v old kk old ); and similarly for cnew
and cnew
1
2 .
addr
• The address secret key matches the public key: aold
pk = PRFaold (0).
sk

• The serial number is computed correctly: snold := PRFsn
(ρold ).
aold
sk

• The coin commitment cmold appears as a leaf of a Merkle-tree with root rt.
• The values add up: v1new + v2new = v old .”
7

new
A resulting pour transaction txPour := (rt, snold , cmnew
1 , cm2 , πPOUR ) is appended to the ledger.
(As before, the transaction is rejected if the serial number sn appears in a previous transaction.)
Now suppose that u does not know, say, the address secret key anew
sk,1 that is associated with the
new because he cannot provide anew as part of the witness
public key anew
.
Then,
u
cannot
spend
c
1
pk,1
sk,1
new
of a subsequent pour operation. Furthermore, when a user who knows anew
sk,1 does spend c1 , the
user u cannot track it, because he knows no information about its revealed serial number, which is
snnew
:= PRFsn
(ρnew
anew
1
1 ).
sk,1
Also observe that txPour reveals no information about how the value of the consumed coin was
divided among the two new fresh coins, nor which coin commitment corresponds to the consumed
coin, nor the address public keys to which the two new fresh coins are targeted. The payment was
conducted in full anonymity.
More generally, a user may pour N old ≥ 0 coins into N new ≥ 0 coins. For simplicity we consider
the case N old = N new = 2, without loss of generality. Indeed, for N old < 2, the user can mint a coin
with value 0 and then provide it as a “null” input, and for N new < 2, the user can create (and discard)
a new coin with value 0. For N old > 2 or N new > 2, the user can compose log N old + log N new of
the 2-input/2-output pours.

Step 4: sending coins. Suppose that anew
pk,1 is the address public key of u1 . In order to allow u1
to actually spend the new coin cnew
produced
above, u must somehow send the secret values in
1
cnew
to
u
.
One
way
is
for
u
to
send
u
a
private
message, but the requisite private communication
1
1
1
channel necessitates additional infrastructure or assumptions. We avoid this “out-of-band” channel
and instead build this capability directly into our construction by leveraging the ledger as follows.
We modify the structure of an address key pair. Each user now has a key pair (addrpk , addrsk ),
where addrpk = (apk , pkenc ) and addrsk = (ask , skenc ). The values (apk , ask ) are generated as before.
In addition, (pkenc , skenc ) is a key pair for a key-private encryption scheme [BBDP01].
new new
Then, u computes the ciphertext C1 that is the encryption of the plaintext (v1new , ρnew
1 , r1 , s1 ),
new
new
under pkenc,1 (which is part of u1 ’s address public key addrsk,1 ), and includes C1 in the pour
transaction txPour . The user u1 can then find and decrypt this message (using his sknew
enc,1 ) by
scanning the pour transactions on the public ledger. Again, note that adding C1 to txPour leaks
neither paid amounts, nor target addresses due to the key-private property of the encryption scheme.
(The user u does the same with cnew
and includes a corresponding ciphertext C2 in txPour .)
2
Step 5: public outputs. The construction so far allows users to mint, merge, and split coins.
But how can a user redeem one of his coins, i.e., convert it back to the base currency (Bitcoin)?
For this, we modify the pour operation to include a public output. When spending a coin, the user
u also specifies a nonnegative vpub and a transaction string info ∈ {0, 1}∗ . The balance equation
in the NP statement POUR is changed accordingly: “v1new + v2new + vpub = v old ”. Thus, of the input
value v old , a part vpub is publicly declared, and its target is specified, somehow, by the string info.
The string info can be used to specify the destination of these redeemed funds (e.g., a Bitcoin wallet
public key).5 Both vpub and info are now included in the resulting pour transaction txPour . (The
public output is optional, as the user u can set vpub = 0.)
Step 6: non-malleability. To prevent malleability attacks on a pour transaction txPour (e.g.,
embezzlement by re-targeting the public output of the pour by modifying info), we further modify
the NP statement POUR and use digital signatures. Specifically, during the pour operation, the user u
(i) samples a key pair (pksig , sksig ) for a one-time signature scheme; (ii) computes hSig := CRH(pksig );
(iii) computes the two values h1 := PRFpk
(hSig ) and h2 := PRFpk
(hSig ), which act as MACs to
aold
aold
sk,1

sk,2

5

These public outputs can be considered as an “input” to a Bitcoin-style transaction, where the string info contains
the Bitcoin output scripts. This mechanism also allows us to support Bitcoin’s public transaction fees.

8

“tie” hSig to both address secret keys; (iv) modifies POUR to include the three values hSig , h1 , h2 and
prove that the latter two are computed correctly; and (v) uses sksig to sign every value associated
with the pour operation, thus obtaining a signature σ, which is included, along with pksig , in txPour .
Since the aold
sk,i are secret, and with high probability hSig changes for each pour transaction, the
values h1 , h2 are unpredictable. Moreover, the signature on the NP statement (and other values)
binds all of these together, as argued in more detail in Appendix C and Appendix D.
This ends the outline of the construction, which is summarized in part in Figure 1. We conclude by
noting that, due to the zk-SNARK, our construction requires a one-time trusted setup of public
parameters. The soundness of the proofs depends on this trust, though anonymity continues to
hold even if the setup is corrupted by a malicious party.
(a) Merke tree over (cm1,cm2,…)
rt
CRH
CRH

CRH

CRH

CRH

CRH

(c) coin commitment

(d) serial number

cm

sn

COMM

PRFsn

s

CRH

COMM

r

CRH

cm1 cm2 cm3 cm4 cm5 cm6 cm7 cm8 …

rt = Merkle-tree root
cm = coin commitment
sn = serial number
v = coin value
r, s = commitment rand.
ρ = serial number rand.
(apk,pkenc) = address public key
(ask,skenc) = address secret key

v
CRH

CRH

(b) coin
c = ((apk,pkenc), v, ρ, r, s, cm)

ρ

PRFaddr

Figure 1: (a) Illustration of the CRH-based Merkle tree over the list CMList of coin commitments. (b) A
coin c. (c) Illustration of the structure of a coin commitment cm. (d) Illustration of the structure of a
coin serial number sn.

1.4

Zerocash

We outline Zerocash, a concrete implementation, at 128 bits of security, of our DAP scheme
construction; see Section 5 for details. Zerocash entails carefully instantiating the cryptographic
ingredients of the construction to ensure that the zk-SNARK, the “heaviest” component, is efficient
enough in practice. In the construction, the zk-SNARK is used to prove/verify a specific NP
statement: POUR. While zk-SNARKs are asymptotically efficient, their concrete efficiency depends
on the arithmetic circuit C that is used to decide the NP statement. Thus, we seek instantiations for
which we can design a relatively small arithmetic circuit CPOUR for verifying the NP statement POUR.
Our approach is to instantiate all of the necessary cryptographic ingredients (commitment
schemes, pseudorandom functions, and collision-resistant hashing) based on SHA256. We first design
a hand-optimized circuit for verifying SHA256 computations (or, more precisely, its compression
function, which suffices for our purposes).6 Then, we use this circuit to construct CPOUR , which
verifies all the necessary checks for satisfying the NP statement CPOUR .
This, along with judicious parameter choices, and a state-of-the-art implementation of a
zk-SNARK for arithmetic circuits [BCTV14] (see Section 2.4), results in a zk-SNARK prover
6

Alternatively, we could have opted to rely on the circuit generators [PGHR13, BCG+ 13, BCTV14], which support
various classes of C programs, by writing C code expressing the POUR checks. However, as discussed later, these generic
approaches are more expensive than our hand-optimized construction.

9

running time of a few minutes and zk-SNARK verifier running time of a few milliseconds. This
allows the DAP scheme implementation to be practical for deployment, as our experiments show.
Zerocash can be integrated into Bitcoin or forks of it (commonly referred to as “altcoins”); we
later describe how this is done.

1.5

Paper organization

The remainder of this paper is organized as follows. Section 2 provides background on zk-SNARKs.
We define DAP schemes in Section 3, and our construction thereof in Section 4. Section 5 discusses
the concrete instantiation in Zerocash. Section 6 describes the integration of Zerocash into existing
ledger-based currencies. Section 7 provides microbenchmarks for our prototype implementation, as
well as results based on full-network simulations. Section 8 describes optimizations. We discuss
concurrent work in Section 9 and summarize our contributions and future directions in Section 10.

2

Background on zk-SNARKs

The main cryptographic primitive used in this paper is a special kind of Succinct Non-interactive
ARgument of Knowledge (SNARK). Concretely, we use a publicly-verifiable preprocessing zeroknowledge SNARK, or zk-SNARK for short. In this section we provide basic background on
zk-SNARKs, provide an informal definition, compare zk-SNARKs with the more familiar notion of
NIZKs, and recall known constructions and implementations.

2.1

Informal definition

We informally define zk-SNARKs for arithmetic circuit satisfiability. We refer the reader to,
e.g., [BCI+ 13] for a formal definition.
For a field F, an F-arithmetic circuit takes inputs that are elements in F, and its gates output
elements in F. We naturally associate a circuit with the function it computes. To model nondeterminism we consider circuits that have an input x ∈ Fn and an auxiliary input a ∈ Fh , called
a witness. The circuits we consider only have bilinear gates.7 Arithmetic circuit satisfiability is
defined analogously to the boolean case, as follows.
Definition 2.1. The arithmetic circuit satisfiability problem of an F-arithmetic circuit C : Fn ×
Fh → Fl is captured by the relation RC = {(x, a) ∈ Fn × Fh : C(x, a) = 0l }; its language is
LC = {x ∈ Fn : ∃ a ∈ Fh s.t. C(x, a) = 0l }.
Given a field F, a (publicly-verifiable preprocessing) zk-SNARK for F-arithmetic circuit
satisfiability is a triple of polynomial-time algorithms (KeyGen, Prove, Verify):
• KeyGen(1λ , C) → (pk, vk). On input a security parameter λ (presented in unary) and an Farithmetic circuit C, the key generator KeyGen probabilistically samples a proving key pk and a
verification key vk. Both keys are published as public parameters and can be used, any number
of times, to prove/verify membership in LC .
• Prove(pk, x, a) → π. On input a proving key pk and any (x, a) ∈ RC , the prover Prove outputs a
non-interactive proof π for the statement x ∈ LC .
A gate with inputs y1 , . . . , ym ∈ F is bilinear if the output is h~a, (1, y1 , . . . , ym )i · h~b, (1, y1 , . . . , ym )i for some
~a, ~b ∈ Fm+1 . These include addition, multiplication, negation, and constant gates.
7

10

• Verify(vk, x, π) → b. On input a verification key vk, an input x, and a proof π, the verifier Verify
outputs b = 1 if he is convinced that x ∈ LC .
A zk-SNARK satisfies the following properties.
Completeness. For every security parameter λ, any F-arithmetic circuit C, and any (x, a) ∈ RC ,
the honest prover can convince the verifier. Namely, b = 1 with probability 1 − negl(λ) in the
following experiment: (pk, vk) ← KeyGen(1λ , C); π ← Prove(pk, x, a); b ← Verify(vk, x, π).
Succinctness. An honestly-generated proof π has Oλ (1) bits and Verify(vk, x, π) runs in time Oλ (|x|).
(Here, Oλ hides a fixed polynomial factor in λ.)
Proof of knowledge (and soundness). If the verifier accepts a proof output by a bounded
prover, then the prover “knows” a witness for the given instance. (In particular, soundness holds
against bounded provers.) Namely, for every poly(λ)-size adversary A, there is a poly(λ)-size
extractor E such that Verify(vk, x, π) = 1 and (x, a) 6∈ RC with probability negl(λ) in the following
experiment: (pk, vk) ← KeyGen(1λ , C); (x, π) ← A(pk, vk); a ← E(pk, vk).
Perfect zero knowledge. An honestly-generated proof is perfect zero knowledge.8 Namely, there
is a polynomial-time simulator Sim such that for all stateful distinguishers D the following two
probabilities are equal:

Pr 

(x, a) ∈ RC
D(π) = 1



(pk, vk) ← KeyGen(1λ , C)
 (x, a) ∈ RC
(x, a) ← D(pk, vk) 
and Pr
D(π) = 1
π ← Prove(pk, x, a)

(the probability that D(π) = 1 on an honest proof)


(pk, vk, trap) ← Sim(1λ , C)
(x, a) ← D(pk, vk)  .
π ← Sim(trap, x)

(the probability that D(π) = 1 on a simulated proof)

Remark. Both proof of knowledge and zero knowledge are essential to the use of zk-SNARKs in
this paper. Indeed, we consider circuits C that verify assertions about cryptographic primitives
(such as using a knowledge of SHA256 pre-image as a binding commitment). Thus it does not suffice
to merely know that, for a given input x, a witness for x ∈ LC exists. Instead, proof of knowledge
ensures that a witness can be efficiently found (by extracting it from the prover) whenever the
verifier accepts a proof. As for zero knowledge, it ensures that a proof leaks no information about
the witness, beyond the fact that x ∈ LC .
Remark. In the security proofs (see Appendix D), we deal with provers producing a vector of inputs
~x together with a vector of corresponding proofs ~π . In such cases, it is convenient to use an extractor
that can extract a vector of witnesses ~a containing a valid witness for each valid proof. This “multiinstance” extraction follows from the “single-instance” one described above [BCCT12, BCCT13].
Namely, if (KeyGen, Prove, Verify) is a zk-SNARK, then for any poly(λ)-size prover adversary A
there exists a poly(λ)-size extractor E such that


(pk, vk) ← KeyGen(1λ , C)
Verify(vk, xi , πi ) = 1
(~x, ~π ) ← A(pk, vk)  ≤ negl(λ) .
Pr  ∃ i s.t.
(xi , ai ) ∈
/ RC
~a ← E(pk, vk)

2.2

Comparison with NIZKs

zk-SNARKs are related to a familiar cryptographic primitive: non-interactive zero-knowledge proofs
of knowledge (NIZKs). Both zk-SNARKs and NIZKs require a one-time trusted setup of public
8
While most zk-SNARK descriptions in the literature only mention statistical zero knowledge, all zk-SNARK
constructions can be made perfect zero knowledge by allowing for a negligible error probability in completeness.

11

parameters (proving and verification keys for zk-SNARKs, and a common reference string for
NIZKs). Both provide the same guarantees of completeness, proof of knowledge, and zero knowledge.
The difference lies in efficiency guarantees. In a NIZK, the proof length and verification time depend
on the NP language being proved. For instance, for the language of circuit satisfiability, the proof
length and verification time in [GOS06b, GOS06a] are linear in the circuit size. Conversely, in a
zk-SNARK, proof length depends only on the security parameter, and verification time depends
only on the instance size (and security parameter) but not on the circuit or witness size.
Thus, zk-SNARKs can be thought of as “succinct NIZKs”, having short proofs and fast verification times. Succinctness comes with a caveat: known zk-SNARK constructions rely on stronger
assumptions than NIZKs do (see below).

2.3

Known constructions and security

There are many zk-SNARK constructions in the literature [Gro10, Lip12, BCI+ 13, GGPR13,
PGHR13, BCG+ 13, Lip13, BCTV14]. We are interested in zk-SNARKs for arithmetic circuit
satisfiability, and the most efficient ones for this language are based on quadratic arithmetic
programs [GGPR13, BCI+ 13, PGHR13, BCG+ 13, BCTV14]; such constructions provide a lineartime KeyGen, quasilinear-time Prove, and linear-time Verify.
Security of zk-SNARKs is based on knowledge-of-exponent assumptions and variants of Diffie–
Hellman assumptions in bilinear groups [Gro10, BB04, Gen04]. While knowledge-of-exponent
assumptions are fairly strong, there is evidence that such assumptions may be inherent for constructing zk-SNARKs [GW11, BCCT12].
Remark (fully-succinct zk-SNARKs). The key generator KeyGen takes a circuit C as input. Thus,
KeyGen’s running time is at least linear in the size of the circuit C. One could require KeyGen to not
have to take C as input, and have its output keys work for all (polynomial-size) circuits C. In such
a case, KeyGen’s running time would be independent of C. A zk-SNARK satisfying this stronger
property is fully succinct. Theoretical constructions of fully-succinct zk-SNARKs are known, based
on various cryptographic assumptions [Mic00, Val08, BCCT13]. Despite achieving essentially-optimal
asymptotics [BFLS91, BGH+ 05, BCGT13b, BCGT13a, BCCT13] no implementations of them have
been reported in the literature to date.

2.4

zk-SNARK implementations

There are three published implementations of zk-SNARKs: (i) Parno et al. [PGHR13] present
an implementation of zk-SNARKs for programs having no data dependencies;9 (ii) Ben-Sasson
et al. [BCG+ 13] present an implementation of zk-SNARKs for arbitrary programs (with data
dependencies); and (iii) Ben-Sasson et al. [BCTV14] present an implementation of zk-SNARKs
that supports programs that modify their own code (e.g., for runtime code generation); their
implementation also reduces costs for programs of larger size and allows for universal key pairs.
Each of the works above also achieves zk-SNARKs for arithmetic circuit satisfiability as a
stepping stone towards their respective higher-level efforts. In this paper we are only interested in
a zk-SNARK for arithmetic circuit satisfiability, and we rely on the implementation of [BCTV14]
for such a zk-SNARK.10 The implementation in [BCTV14] is itself based on the protocol of Parno
et al. [PGHR13]. We thus refer the interested reader to [PGHR13] for details of the protocol, its
9

They only support programs where array indices are restricted to be known compile-time constants; similarly,
loop iteration counts (or at least upper bounds to these) must be known at compile time.
10
In [BCTV14], one optimization to the verifier’s runtime requires preprocessing the verification key vk; for simplicity,
we do not use this optimization.

12

intuition, and its proof of security; and to [BCTV14] for the implementation and its performance.
In terms of concrete parameters, the implementation of [BCTV14] provides 128 bits of security, and
the field F is of a 256-bit prime order p.

3

Definition of a decentralized anonymous payment scheme

We introduce the notion of a decentralized anonymous payment scheme (DAP scheme), extending
the notion of decentralized e-cash [MGGR13]. Later, in Section 4, we provide a construction.

3.1

Data structures

We begin by describing, and giving intuition about, the data structures used by a DAP scheme.
The algorithms that use and produce these data structures are introduced in Section 3.2.
Basecoin ledger. Our protocol is applied on top of a ledger-based base currency such as Bitcoin;
for generality we refer to this base currency as Basecoin. At any given time T , all users have access
to LT , the ledger at time T , which is a sequence of transactions. The ledger is append-only (i.e.,
T < T 0 implies that LT is a prefix of LT 0 ).11 The transactions in the ledger include both Basecoin
transactions as well as two new transaction types described below.
Public parameters. A list of public parameters pp is available to all users in the system. These
are generated by a trusted party at the “start of time” and are used by the system’s algorithms.
Addresses. Each user generates at least one address key pair (addrpk , addrsk ). The public key
addrpk is published and enables others to direct payments to the user. The secret key addrsk is used
to receive payments sent to addrpk . A user may generate any number of address key pairs.
Coins. A coin is a data object c, to which we associate the following.
• A coin commitment, denoted cm(c): a string that appears on the ledger once c is minted.
• A coin value, denoted v(c): the denomination of c, as measured in basecoins, as an integer
between 0 and a maximum value vmax (which is a system parameter).
• A coin serial number, denoted sn(c): a unique string associated with c, used to prevent double
spending.
• A coin address, denoted addrpk (c): an address public key, representing who owns c.
Any other quantities associated with a coin c (e.g., various trapdoors) are implementation details.
New transactions. Besides Basecoin transactions, there are two new types of transactions.
• Mint transactions. A mint transaction txMint is a tuple (cm, v, ∗), where cm is a coin commitment,
v is a coin value, and ∗ denotes other (implementation-dependent) information. The transaction
txMint records that a coin c with coin commitment cm and value v has been minted.
old
new
new
• Pour transactions. A pour transaction txPour is a tuple (rt, snold
1 , sn2 , cm1 , cm2 , vpub , info, ∗),
old
old
new are
where rt is a root of a Merkle tree, sn1 , sn2 are two coin serial numbers, cmnew
1 , cm2
two coin commitments, vpub is a coin value, info is an arbitrary string, and ∗ denotes other
(implementation-dependent) information. The transaction txPour records the pouring of two
old
old
old
input (and now consumed) coins cold
1 , c2 , with respective serial numbers sn1 , sn2 , into two
new
new
new
new
new output coins c1 , c2 , with respective coin commitments cm1 , cm2 , as well as a public
output vpub (which may be zero). Furthermore, txPour also records an information string info
(perhaps containing information on who is the recipient of vpub basecoins) and that, when this
transaction was made, the root of the Merkle tree over coin commitments was rt (see below).
11

In reality, the Basecoin ledger (such as the one of Bitcoin) is not perfect and may incur temporary inconsistencies.
In this respect our construction is as good as the underlying ledger. We discuss the effects of this on anonymity and
mitigations in Section 6.4.

13

Commitments of minted coins and serial numbers of spent coins. For any given time T ,
• CMListT denotes the list of all coin commitments appearing in mint and pour transactions in LT ;
• SNListT denotes the list of all serial numbers appearing in pour transactions in LT .
While both of these lists can be deduced from LT , it will be convenient to think about them as
separate (as, in practice, these may be separately maintained for efficiency reasons; cf. Section 8.3).
Merkle tree over commitments. For any given time T , TreeT denotes a Merkle tree over
CMListT and rtT its root. Moreover, the function PathT (cm) gives the authentication path from a
coin commitment cm appearing in CMListT to the root of TreeT .12 For convenience, we assume that
LT also stores rtT 0 for all T 0 ≤ T (i.e., it stores all past Merkle tree roots).

3.2

Algorithms

A DAP scheme Π is a tuple of polynomial-time algorithms
(Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive)
with the following syntax and semantics.
System setup. The algorithm Setup generates a list of public parameters:
Setup
• inputs: security parameter λ
• outputs: public parameters pp
The algorithm Setup is executed by a trusted party. The resulting public parameters pp are published
and made available to all parties (e.g., by embedding them into the protocol’s implementation). The
setup is done only once; afterwards, no trusted party is needed, and no global secrets or trapdoors
are kept.
Creating payment addresses. The algorithm CreateAddress generates a new address key pair:
CreateAddress
• inputs: public parameters pp
• outputs: address key pair (addrpk , addrsk )
Each user generates at least one address key pair (addrpk , addrsk ) in order to receive coins. The
public key addrpk is published, while the secret key addrsk is used to redeem coins sent to addrpk . A
user may generate any number of address key pairs; doing so does not require any interaction.
Minting coins. The algorithm Mint generates a coin (of a given value) and a mint transaction:
Mint
• inputs:
– public parameters pp
– coin value v ∈ {0, 1, . . . , vmax }
– destination address public key addrpk
• outputs: coin c and mint transaction txMint
A system parameter, vmax , caps the value of any single coin. The output coin c has value v and
coin address addrpk ; the output mint transaction txMint equals (cm, v, ∗), where cm is the coin
commitment of c.
12
While we refer to Mekle trees for simplicity, it is straightforward to extend the definition to allow other data
structures representing sets with fast insertion and efficient proofs of membership.

14

Pouring coins. The Pour algorithm transfers value from input coins into new output coins,
marking the input coins as consumed. Moreover, a fraction of the input value may be publicly
revealed. Pouring allows users to subdivide coins into smaller denominations, merge coins, and
transfer ownership of anonymous coins, or make public payments.13
Pour
• inputs:
– public parameters pp
– the Merkle root rt
old
– old coins cold
1 , c2
old
– old addresses secret keys addrold
sk,1 , addrsk,2
– authentication path path1 from commitment cm(cold
1 ) to root rt,
authentication path path2 from commitment cm(cold
2 ) to root rt
new
new
– new values v1 , v2
new
– new addresses public keys addrnew
pk,1 , addrpk,2
– public value vpub
– transaction string info
new and pour transaction tx
• outputs: new coins cnew
Pour
1 , c2
old
Thus, the Pour algorithm takes as input two distinct input coins cold
1 , c2 , along with corresponding
old
old
address secret keys addrsk,1 , addrsk,2 (required to redeem the two input coins). To ensure that
old
cold
1 , c2 have been previously minted, the Pour algorithm also takes as input the Merkle root rt
(allegedly, equal to the root of Merkle tree over all coin commitments so far), along with two
old
authentication paths path1 , path2 for the two coin commitments cm(cold
1 ), cm(c2 ). Two input values
new to be generated, and two input
v1new , v2new specify the values of two new anonymous coins cnew
1 , c2
new
new
new
address public keys addrpk,1 , addrpk,2 specify the recipients of c1 , cnew
2 . A third value, vpub , specifies
the amount to be publicly spent (e.g., to redeem coins or pay transaction fees). The sum of output
values v1new + v2new + vpub must be equal to the sum of the values of the input coins (and cannot
exceed vmax ). Finally, the Pour algorithm also receives an arbitrary string info, which is bound into
the output pour transaction txPour .
new and a pour transaction tx
The Pour algorithm outputs two new coins cnew
Pour . The
1 , c2
old
old
new
new
new
new
transaction txPour equals (rt, sn1 , sn2 , cm1 , cm2 , vpub , info, ∗), where cm1 , cm2 are the two
coin commitments of the two output coins, and ∗ denotes other (implementation-dependent)
information. Crucially, txPour reveals only one value, the public value vpub (which may be zero); it
does not reveal the payment addresses or values of the old or new coins.

Verifying transactions. The algorithm VerifyTransaction checks the validity of a transaction:
VerifyTransaction
• inputs:
– public parameters pp
– a (mint or pour) transaction tx
– the current ledger L
• outputs: bit b, equals 1 iff the transaction is valid
Both mint and pour transactions must be verified before being considered well-formed. In practice,
transactions can be verified by the nodes in the distributed system maintaining the ledger, as well
13

We consider pours with 2 inputs and 2 outputs, for simplicity and (as discussed in Section 1.3) without loss of
generality.

15

as by users who rely on these transactions.
Receiving coins. The algorithm Receive scans the ledger and retrieves unspent coins paid to a
particular user address:
Receive
• inputs:
– recipient address key pair (addrpk , addrsk )
– the current ledger L
• outputs: set of (unspent) received coins
When a user with address key pair (addrpk , addrsk ) wishes to receive payments sent to addrpk , he
uses the Receive algorithm to scan the ledger. For each payment to addrpk appearing in the ledger,
Receive outputs the corresponding coins whose serial numbers do not appear on the ledger L. Coins
received in this way may be spent, just like minted coins, using the Pour algorithm. (We only require
Receive to detect coins paid to addrpk via the Pour algorithm and not also detect coins minted by
the user himself.)
Next, we describe completeness (Section 3.3) and security (Section 3.4).

3.3

Completeness

Completeness of a DAP scheme requires that unspent coins can be spent. More precisely, consider a
ledger sampler S outputting a ledger L. If c1 and c2 are two coins whose coin commitments appear
in (valid) transactions on L, but their serial numbers do not appear in L, then c1 and c2 can be
spent using Pour. Namely, running Pour results in a pour transaction txPour that VerifyTransaction
accepts, and the new coins can be received by the intended recipients (by using Receive); moreover,
txPour correctly records the intended vpub and transaction string info. This property is formalized
via an incompleteness experiment INCOMP.
Definition 3.1. A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive)
is complete if no polynomial-size ledger sampler S wins INCOMP with more than negligible
probability. (See Appendix B for details.)

3.4

Security

Security of a DAP scheme is characterized by three properties, which we call ledger indistinguishability,
transaction non-malleability, and balance.
Definition 3.2. A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive)
is secure if it satisfies ledger indistinguishability, transaction non-malleability, and balance.
Below, we provide an informal overview of each property, and defer formal definitions to Appendix C.
Each property is formalized as a game between an adversary A and a challenger C. In each game,
the behavior of honest parties is realized via a DAP scheme oracle ODAP , which maintains a ledger L
and provides an interface for executing CreateAddress, Mint, Pour and Receive algorithms for honest
parties. To elicit behavior from honest parties, A passes a query to C, which (after sanity checks)
proxies the query to ODAP . For each query that requests an honest party to perform an action, A
specifies identities of previous transactions and the input values, and learns the resulting transaction,
but not any of the secrets or trapdoors involved in producing that transaction. The oracle ODAP
also provides an Insert query that allows A to directly add aribtrary transactions to the ledger L.
16

Ledger indistinguishability. This property captures the requirement that the ledger reveals no
new information to the adversary beyond the publicly-revealed information (values of minted coins,
public values, information strings, total number of transactions, etc.), even when the adversary can
adaptively induce honest parties to perform DAP operations of his choice. That is, no bounded
adversary A can distinguish between two ledgers L0 and L1 , constructed by A using queries to two
DAP scheme oracles, when the queries to the two oracles are publicly consistent: they have matching
type and are identical in terms of publicly-revealed information and the information related to
addresses controlled by A.
Ledger indistinguishability is formalized by an experiment L-IND that proceeds as follows.
First, a challenger samples a random bit b and initializes two DAP scheme oracles O0DAP and
O1DAP , maintaining ledgers L0 and L1 . Throughout, the challenger allows A to issue queries to
O0DAP and O1DAP , thus controlling the behavior of honest parties on L0 and L1 . The challenger
provides the adversary with the view of both ledgers, but in randomized order: LLeft := Lb and
LRight := L1−b . The adversary’s goal is to distinguish whether the view he sees corresponds to
(LLeft , LRight ) = (L0 , L1 ), i.e. b = 0, or to (LLeft , LRight ) = (L1 , L0 ), i.e. b = 1.
At each round of the experiment, the adversary issues queries in pairs Q, Q0 of matching query
type. If the query type is CreateAddress, then the same address is generated at both oracles. If
it is to Mint, Pour or Receive, then Q is forwarded to L0 and Q0 to L1 ; for Insert queries, query
Q is forwarded to LLeft and Q0 is forwarded to LRight . The adversary’s queries are restricted in the
sense that they must maintain the public consistency of the two ledgers. For example, the public
values for Pour queries must be the same, as well as minted amounts for Mint queries.
At the conclusion of the experiment, A outputs a guess b0 , and wins when b = b0 . Ledger
indistinguishability requires that A wins L-IND with probability at most negligibly greater than 1/2.
Transaction non-malleability. This property requires that no bounded adversary A can alter
any of the data stored within a (valid) pour transaction txPour . This transaction non-malleability
prevents malicious attackers from modifying others’ transactions before they are added to the ledger
(e.g., by re-targeting the Basecoin public output of a pour transaction).
Transaction non-malleability is formalized by an experiment TR-NM, in which A adaptively
interacts with a DAP scheme oracle ODAP and then outputs a pour transaction tx∗ . Letting T
denote the set of pour transactions returned by ODAP , and L denote the final ledger, A wins the
game if there exists tx ∈ T , such that (i) tx∗ =
6 tx; (ii) tx∗ reveals a serial number contained in tx;
∗
and (iii) both tx and tx are valid with respect to the ledger L0 containing all transactions preceding
tx on L. In other words, A wins the game if tx∗ manages to modify some previous pour transaction
to spend the same coin in a different way.
Transaction non-malleability requires that A wins TR-NM with only negligible probability. (Note
that A can of course produce valid pour transactions that are unrelated to those in T ; the condition
that tx∗ reveals a serial number of a previously-spent coin captures non-malleability.)
Balance. This property requires that no bounded adversary A can own more money than what
he minted or received via payments from others.
Balance is formalized by an experiment BAL, in which A adaptively interacts with a DAP scheme
oracle ODAP and then outputs a set of coins Scoin . Letting ADDR be set of addresses returned by
CreateAddress queries (i.e., addresses of “honest” users), A wins the game if the total value he
can spend or has spent (either as coins or Basecoin public outputs) is greater than the value he
has minted or received. That is, A wins if vUnspent + vBasecoin + vA→ADDR > vMint + vADDR→A where:
(i) vUnspent is the total value of unspent coins in Scoin ; (ii) vBasecoin is the total value of public outputs
placed by A on the ledger; (iii) vMint is the total value of A’s mint transactions; (iv) vADDR→A is
the total value of payments received by A from addresses in ADDR; (v) vA→ADDR is the total value
17

of payments sent by A to addresses in ADDR.
Balance requires that A wins BAL with only negligible probability.

4

Construction of a decentralized anonymous payment scheme

We show how to construct a DAP scheme (introduced in Section 3) using zk-SNARKs and other
building blocks. Later, in Section 5, we give a concrete instantiation of this construction.

4.1

Cryptographic building blocks

We first introduce notation for the standard cryptographic building blocks that we use. We
assume familiarity with the definitions of these building blocks; for more details, see, e.g., [KL07].
Throughout, λ denotes the security parameter.
Collision-resistant hashing. We use a collision-resistant hash function CRH : {0, 1}∗ → {0, 1}O(λ) .
Pseudorandom functions. We use a pseudorandom function family PRF = {PRFx : {0, 1}∗ →
{0, 1}O(λ) }x where x denotes the seed. From PRFx , we derive three “non-overlapping” pseudorandom
pk
functions, chosen arbitrarily as PRFaddr
(z) := PRFx (00kz) , PRFsn
x
x (z) := PRFx (01kz) , PRFx (z) :=
sn
PRFx (10kz). Furthermore, we assume that PRF is also collision resistant, in the sense that it is
sn 0
infeasible to find (x, z) 6= (x0 , z 0 ) such that PRFsn
x (z) = PRFx0 (z ).
Statistically-hiding commitments. We use a commitment scheme COMM where the binding property holds computationally, while the hiding property holds statistically. It is denoted
{COMMx : {0, 1}∗ → {0, 1}O(λ) }x where x denotes the commitment trapdoor. Namely, to reveal a
commitment cm to a value z, it suffices to provide z and the trapdoor x; then one can check that
cm = COMMx (z).
One-time strongly-unforgeable digital signatures. We use a digital signature scheme Sig =
(Gsig , Ksig , Ssig , Vsig ) that works as follows.
• Gsig (1λ ) → ppsig . Given a security parameter λ (presented in unary), Gsig samples public parameters
ppsig for the encryption scheme.
• Ksig (ppsig ) → (pksig , sksig ). Given public parameters ppsig , Ksig samples a public key and a secret
key for a single user.
• Ssig (sksig , m) → σ. Given a secret key sksig and a message m, Ssig signs m to obtain a signature σ.
• Vsig (pksig , m, σ) → b. Given a public key pksig , message m, and signature σ, Vsig outputs b = 1 if
the signature σ is valid for message m; else it outputs b = 0.
The signature scheme Sig satisfies the security property of one-time strong unforgeability against
chosen-message attacks (SUF-1CMA security).
Key-private public-key encryption. We use a public-key encryption scheme Enc = (Genc , Kenc ,
Eenc , Denc ) that works as follows.
• Genc (1λ ) → ppenc . Given a security parameter λ (presented in unary), Genc samples public
parameters ppenc for the encryption scheme.
• Kenc (ppenc ) → (pkenc , skenc ). Given public parameters ppenc , Kenc samples a public key and a
secret key for a single user.
• Eenc (pkenc , m) → c. Given a public key pkenc and a message m, Eenc encrypts m to obtain a
ciphertext c.
• Denc (skenc , c) → m. Given a secret key skenc and a ciphertext c, Denc decrypts c to produce a
message m (or ⊥ if decryption fails).
The encryption scheme Enc satisfies two security properties: (i) ciphertext indistinguishability under
chosen-ciphertext attack (IND-CCA security); and (ii) key indistinguishability under chosen-ciphertext
18

attack (IK-CCA security). While the first property is standard, the second is less known; informally,
IK-CCA requires that ciphertexts cannot be linked to the public key used to encrypt them, or to other
ciphertexts encrypted with the same public key. For definitions, we refer the reader to [BBDP01].

4.2

zk-SNARKs for pouring coins

As outlined in Section 1.3, our construction invokes a zk-SNARK for a specific NP statement, POUR,
which we now define. We first recall the context motivating POUR. When a user u pours “old” coins
old
new new
cold
1 , c2 into new coins c1 , c2 , a corresponding pour transaction
old
new
new
txPour = (rt, snold
1 , sn2 , cm1 , cm2 , vpub , info, ∗)

is generated. In our construction, we need to provide evidence in “∗” that various conditions
were respected by the pour operation. Concretely, txPour should demonstrate that (i) u owns
old
old old
cold
1 , c2 ; (ii) coin commitments for c1 , c2 appear somewhere on the ledger; (iii) the revealed
old
old
old
new
new are
serial numbers sn1 , sn2 are of c1 , cold
2 ; (iv) the revealed coin commitments cm1 , cm2
new
new
of c1 , c2 ; (v) balance is preserved. Our construction achieves this by including a zk-SNARK
proof πPOUR for the statement POUR which checks the above invariants (as well as others needed for
non-malleability).
The statement POUR. Concretely, the NP statement POUR is defined as follows.
old
new
new
• Instances are of the form x = (rt, snold
1 , sn2 , cm1 , cm2 , vpub , hSig , h1 , h2 ). Thus, an instance x
specifies a root rt for a CRH-based Merkle tree (over the list of commitments so far), the two
serial numbers of the consumed coins, two coin commitments for the two new coins, a public
value, and fields hSig , h1 , h2 used for non-malleability.
old
old
old
new new
• Witnesses are of the form a = (path1 , path2 , cold
1 , c2 , addrsk,1 , addrsk,2 , c1 , c2 ) where, for each
i ∈ {1, 2}:
old
old old old old
old
cold
i = (addrpk,i , vi , ρi , ri , si , cmi ) ,
new new new new
new
cnew
= (addrnew
, ρi , ri , si , cmnew
as in x,
i
i ) for the same cmi
pk,i , vi
old
old
addrold
pk,i = (apk,i , pkenc,i ) ,
new
new
addrnew
pk,i = (apk,i , pkenc,i ) ,
old
old
addrold
sk,i = (ask,i , skenc,i ) .

Thus, a witness a specifies authentication paths for the two new coin commitments, the entirety
of coin information about both the old and new coins, and address secret keys for the old coins.
Given a POUR instance x, a witness a is valid for x if the following holds:
1. For each i ∈ {1, 2}:
old
(a) The coin commitment cmold
i of ci appears on the ledger, i.e., pathi is a valid authentication
old
path for leaf cmi with respect to root rt, in a CRH-based Merkle tree.
addr
old
old
(b) The address secret key aold
sk,i matches the address public key of ci , i.e., apk,i = PRFaold (0).
sk,i

sn
old
old
old
(c) The serial number snold
i of ci is computed correctly, i.e., sni = PRFaold (ρi ).
sk,i

old
old
old
(d) The coin cold
(COMMrold (aold
i is well-formed, i.e., cmi = COMMsold
pk,i kρi )kvi ).
i
i
new
new
new
new
(e) The coin ci is well-formed, i.e., cmi = COMMsnew
(COMMrinew (apk,i kρi )kvinew ).
i
pk
(f) The address secret key aold
sk,i ties hSig to hi , i.e., hi = PRFaold (ikhSig ).
sk,i

19

2. Balance is preserved: v1new + v2new + vpub = v1old + v2old (with v1old , v2old ≥ 0 and v1old + v2old ≤ vmax ).
Recall that in this paper zk-SNARKs are relative to the language of arithmetic circuit satisfiability
(see Section 2); thus, we express the checks in POUR via an arithmetic circuit, denoted CPOUR . In
particular, the depth dtree of the Merkle tree needs to be hardcoded in CPOUR , and we thus make it a
parameter of our construction (see below); the maximum number of supported coins is then 2dtree .

4.3

Algorithm constructions

We proceed to describe the construction of the DAP scheme Π = (Setup, CreateAddress, Mint, Pour,
VerifyTransaction, Receive) whose intuition was given in Section 1.3. Figure 2 gives the pseudocode
for each one of the six algorithms in Π, in terms of the building blocks introduced in Section 4.1
and Section 4.2. In the construction, we hardcode two quantities: the maximum value of a coin,
vmax , and the depth of the Merkle tree, dtree .

4.4

Completeness and security

Our main theorem states that the above construction is indeed a DAP scheme.
Theorem 4.1. The tuple Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive), as defined in Section 4.3, is a complete (cf. Definition 3.1) and secure (cf. Definition 3.2) DAP scheme.
We provide a proof of Theorem 4.1 in Appendix D. We note that our construction can be modified
to yield statistical (i.e., everlasting) anonymity; see the discussion in Section 8.1.
Remark (trusted setup). Security of Π relies on a trusted party running Setup to generate the
public parameters (once and for all). This trust is needed for the transaction non-malleability
and balance properties but not for ledger indistinguishability. Thus, even if a powerful espionage
agency were to corrupt the setup, anonymity will still be maintained. Moreover, if one wishes to
mitigate the trust requirements of this step, one can conduct the computation of Setup using secure
multiparty computation techniques; we leave this to future work.
Remark (use of pp). According to the definition of a DAP scheme (see Section 3), the public
parameters pp are given as input to each one of the six algorithms; this is also how we presented
our construction in Figure 2. However, in our construction, the public parameters pp equal a
tuple (pkPOUR , vkPOUR , ppenc , ppsig ), and not every algorithm needs every component of pp. Concretely,
CreateAddress only needs ppenc ; Mint only the security parameter λ; Pour only pkPOUR and ppsig ;
VerifyTransaction only vkPOUR ; and Receive only λ. In particular, since we rely on zk-SNARKs to
prove/verify POUR, pkPOUR is of constant, but large, size, and is only required by Pour. All other
components of pp are of small constant size.
Remark (checking received coins in ledger). The algorithm Receive tests whether the serial number
of a received coin already appears on the ledger, in order not to output coins that the user has
already received and spent by himself. Other users are, in any case, unable to spend coins addressed
to this user.

5

Zerocash

We describe a concrete instantiation of a DAP scheme; this instantiation forms the basis of Zerocash.
Later, in Section 6, we discuss how Zerocash can be integrated with existing ledger-based currencies.
20

Setup
• inputs: security parameter λ
• outputs: public parameters pp
1.
2.
3.
4.
5.
6.

Pour
• inputs:
– public parameters pp
– the Merkle root rt
old
– old coins cold
1 , c2
old
– old addresses secret keys addrold
sk,1 , addrsk,2
old
– path path1 from commitment cm(c1 ) to root rt,
path path2 from commitment cm(cold
2 ) to root rt
– new values v1new , v2new
new
– new addresses public keys addrnew
pk,1 , addrpk,2
– public value vpub
– transaction string info
new
• outputs: new coins cnew
and pour transaction txPour
1 , c2

Construct CPOUR for POUR at security λ.
Compute (pkPOUR , vkPOUR ) := KeyGen(1λ , CPOUR ).
Compute ppenc := Genc (1λ ).
Compute ppsig := Gsig (1λ ).
Set pp := (pkPOUR , vkPOUR , ppenc , ppsig ).
Output pp.

CreateAddress
• inputs: public parameters pp
• outputs: address key pair (addrpk , addrsk )
1.
2.
3.
4.
5.
6.

1. For each i ∈ {1, 2}:
old
old
old old
old
old
(a) Parse cold
i as (addrpk,i , vi , ρi , ri , si , cmi ).
old
old
old
(b) Parse addrsk,i as (ask,i , skenc,i ).
old
sn
(c) Compute snold
i := PRFaold (ρi ).

Compute (pkenc , skenc ) := Kenc (ppenc ).
Randomly sample a PRFaddr seed ask .
Compute apk = PRFaddr
ask (0).
Set addrpk := (apk , pkenc ).
Set addrsk := (ask , skenc ).
Output (addrpk , addrsk ).

sk,i

new
new
(d) Parse addrnew
pk,i as (apk,i , pkenc,i ).
(e) Randomly sample a PRFsn seed ρnew
i .
(f) Randomly sample two COMM trapdoors rinew , snew
i .
new
(g) Compute kinew := COMMrinew (anew
pk,i kρi ).
(vinew kkinew ).
(h) Compute cmnew
:= COMMsnew
i
i
new
new
new
new
(i) Set cnew
:=
(addr
,
v
,
ρ
,
rinew , snew
i
i
i
i , cmi ).
pk,i
new
new
new
new
new
(j) Set Ci := Eenc (pkenc,i , (vi , ρi , ri , si )).
2. Generate (pksig , sksig ) := Ksig (ppsig ).
3. Compute hSig := CRH(pksig ).
4. Compute h1 := PRFpk
(1khSig ) and h2 := PRFpk
(2khSig ).
aold
aold

Mint
• inputs:
– public parameters pp
– coin value v ∈ {0, 1, . . . , vmax }
– destination address public key addrpk
• outputs: coin c and mint transaction txMint
1.
2.
3.
4.
5.
6.
7.
8.

Parse addrpk as (apk , pkenc ).
Randomly sample a PRFsn seed ρ.
Randomly sample two COMM trapdoors r, s.
Compute k := COMMr (apk kρ).
Compute cm := COMMs (vkk).
Set c := (addrpk , v, ρ, r, s, cm).
Set txMint := (cm, v, ∗), where ∗ := (k, s).
Output c and txMint .

sk,1

sk,2

old
new
new
Set x := (rt, snold
1 , sn2 , cm1 , cm2 , vpub , hSig , h1 , h2 ).
old
old
old
new
new
Set a := (path1 , path2 , c1 , c2 , addrold
sk,1 , addrsk,2 , c1 , c2 ).
Compute πPOUR := Prove(pkPOUR , x, a).
Set m := (x, πPOUR , info, C1 , C2 ).
Compute σ := Ssig (sksig , m).
old
new
new
Set txPour := (rt, snold
1 , sn2 , cm1 , cm2 , vpub , info, ∗), where
∗ := (pksig , h1 , h2 , πPOUR , C1 , C2 , σ).
new
11. Output cnew
and txPour .
1 , c2

5.
6.
7.
8.
9.
10.

VerifyTransaction
• inputs:
– public parameters pp
– a (mint or pour) transaction tx
– the current ledger L
• outputs: bit b, equals 1 iff the transaction is valid

Receive
• inputs:
– public parameters pp
– recipient address key pair (addrpk , addrsk )
– the current ledger L
• outputs: set of received coins

1. If given a mint transaction tx = txMint :
1. Parse addrpk as (apk , pkenc ).
(a) Parse txMint as (cm, v, ∗), and ∗ as (k, s).
2. Parse addrsk as (ask , skenc ).
(b) Set cm0 := COMMs (vkk).
3. For each Pour transaction txPour on the ledger:
(c) Output b := 1 if cm = cm0 , else output b := 0.
old
new
new
(a) Parse txPour as (rt, snold
1 , sn2 , cm1 , cm2 , vpub , info, ∗),
2. If given a pour transaction tx = txPour :
old
old
new
new
and ∗ as (pksig , h1 , h2 , πPOUR , C1 , C2 , σ).
(a) Parse txPour as (rt, sn1 , sn2 , cm1 , cm2 , vpub , info, ∗), and
(b) For each i ∈ {1, 2}:
∗ as (pksig , h1 , h2 , πPOUR , C1 , C2 , σ).
old
old
old
i. Compute (vi , ρi , ri , si ) := Denc (skenc , Ci ).
(b) If snold
1 or sn2 appears on L (or sn1 = sn2 ), output b := 0.
ii. If Denc ’s output is not ⊥, verify that:
(c) If the Merkle root rt does not appear on L, output b := 0.
(d) Compute hSig := CRH(pksig ).
• cmnew
equals COMMsi (vi kCOMMri (apk kρi ));
i
old
old
new
new
• sni := PRFsn
(e) Set x := (rt, sn1 , sn2 , cm1 , cm2 , vpub , hSig , h1 , h2 ).
ask (ρi ) does not appear on L.
(f) Set m := (x, πPOUR , info, C1 , C2 ).
iii. If both checks succeed, output
(g) Compute b := Vsig (pksig , m, σ).
ci := (addrpk , vi , ρi , ri , si , cmnew
i ).
(h) Compute b0 := Verify(vkPOUR , x, πPOUR ), and output b ∧ b0 .
Figure 2: Construction of a DAP scheme using zk-SNARKs and other ingredients.

21

5.1

Instantiation of building blocks

We instantiate the DAP scheme construction from Section 4 (see Figure 2), aiming at a level of
security of 128 bits. Doing so requires concrete choices, described next.
CRH, PRF, COMM from SHA256. Let H be the SHA256 compression function, which maps
a 512-bit input to a 256-bit output. We mostly rely on H, rather than the “full” hash, since
this suffices for our fixed-size single-block inputs, and it simplifies the construction of CPOUR (see
Section 5.2). We instantiate CRH, PRF, COMM via H (under suitable assumptions on H).
First, we instantiate the collision-resistant function CRH as H(z) for z ∈ {0, 1}512 ; this function
compresses “two-to-one”, so it can be used to construct binary Merkle trees.14
Next, we instantiate the pseudorandom function PRFx (z) as H(xkz), with x ∈ {0, 1}256 as the
seed, and z ∈ {0, 1}256 as the input.15 Thus, the derived functions are:
PRFaddr
(z) := H(xk00kz) ,
x

PRFsn
x (z) := H(xk01kz) ,

PRFpk
x (z) := H(xk10kz) ,

with x ∈ {0, 1}256 and z ∈ {0, 1}254 .
As for the commitment scheme COMM, we only use it in the following pattern:
k := COMMr (apk kρ) ,
cm := COMMs (vkk) .
Due to our instantiation of PRF, apk is 256 bits. So we can set ρ also to 256 bits and r to
256 + 128 = 384 bits; then we can compute
k := COMMr (apk kρ) as H(rk[H(apk kρ)]128 ) .
Above, [·]128 denotes that we are truncating the 256-bit string to 128 bits (say, by dropping leastsignificant bits, as in our implementation). Heuristically, for any string z ∈ {0, 1}128 , the distribution
induced by H(rkz) is 2−128 -close to uniform, and this forms the basis of the statistically-hiding
property. For computing cm, we set coin values to be 64-bit integers (so that, in particular,
vmax = 264 − 1 in our implementation), and then compute
cm := COMMs (vkk) as H(kk0192 kv) .
Noticeably, above we are ignoring the commitment randomness s. The reason is that we already
know that k, being the output of a statistically-hiding commitment, can serve as randomness for
the next commitment scheme.
Instantiating the NP statement POUR. The above choices imply a concrete instantiation of
the NP statement POUR (see Section 4.2). Specifically, in our implementation, POUR checks that the
following holds, for each i ∈ {1, 2}:
• pathi is an authentication path for leaf cmold
i with respect to root rt, in a CRH-based Merkle tree;
old
old
256
• apk,i = H(ask,i k0 );
old
old
• snold
i = H(ask,i k01k[ρi ]254 );
old
old
old
192 kv old );
• cmold
i = H(H(ri k[H(apk,i kρi )]128 )k0
i
14

A single exception: we still compute hSig according to the full hash SHA256, rather than its compression function,
because there is no need for this computation to be verified by CPOUR .
15
This assumption is reminiscent of previous works analyzing the security of hash-based constructions (e.g., [Bel06]).
However in this work we assume that a portion of the compression function is the seed for the pseudorandom function,
rather than using the chaining variable as in [Bel06].

22

new
192 kv new ); and
• cmnew
= H(H(rinew k[H(anew
i
i
pk,i kρi )]128 )k0
• hi = H(aold
k10kb
k[h
]
)
where
b
:=
0
and
b2 := 1.
i
253
1
Sig
sk,i
new
new
Moreover, POUR checks that v1 + v2 + vpub = v1old + v2old , with v1old , v2old ≥ 0 and v1old + v2old < 264 .
Finally, as mentioned, in order for CPOUR to be well-defined, we need to fix a Merkle-tree depth
dtree . In our implementation, we fix dtree = 64, and thus support up to 264 coins.

Instantiating Sig. For the signature scheme Sig, we use ECDSA to retain consistency and
compatibility with the existing bitcoind source code. However, standard ECDSA is malleable:
both (r, s) and (r, −s) verify as valid signatures. We use a non-malleable variant, where s is restricted
to the “lower half” of field elements. While we are not aware of a formal SUF-1CMA proof for this
variant, its use is consistent with proposals to resolve Bitcoin transaction malleability [Wui14].16
Instantiating Enc. For the encryption scheme Enc, we use the key-private Elliptic-Curve Integrated
Encryption Scheme (ECIES) [Cer00]; it is one of the few standardized key-private encryption schemes
with available implementations.

5.2

Arithmetic circuit for pouring coins

Our DAP scheme construction from Section 4 (see Figure 2) also requires zk-SNARKs relative
to the NP statement POUR. These are obtained by invoking a zk-SNARK for arithmetic circuit
satisfiability (see Section 2.4) on an arithmetic circuit CPOUR , which verifies the NP statement POUR.
In our instantiation, we rely on the implementation of [BCTV14] for the basic zk-SNARK (see
Section 2.4), and apply it to the circuit CPOUR whose construction is described next.
5.2.1

An arithmetic circuit for verifying SHA256’s compression function

The vast majority of the “verification work” in POUR is verifying computations of H, the compression
function of SHA256 (see Section 5.1). Thus, we begin by discussing our construction of an arithmetic
circuit CH for verifying SHA256 computations. Later, in Section 5.2.2, we discuss the construction
of CPOUR , given the circuit CH .
We wish to construct an arithmetic circuit CH such that, for every 256-bit digest h and 512-bit
input z, (h, z) ∈ RCH if and only if h = H(z). Naturally, our goal is to minimize the size of
CH . Our high-level strategy is to construct CH , piece by piece, by closely following the SHA256
official specification [Nat12]. For each subcomputation of SHA256, we use nondeterminism and field
operations to verify the subcomputation using as few gates as possible.
Overview of SHA256’s compression function. The primitive unit in SHA256 is a 32-bit word.
All subcomputations are simple word operations: three bitwise operations (and, or, xor), shift-right,
rotate-right, and addition modulo 232 . The compression function internally has a state of 8 words,
initialized to a fixed value, and then transformed in 64 successive rounds by following the 64-word
message schedule (deduced from the input z). The 256-bit output is the concatenation of the 8
words of the final state.
Representing a state. We find that, for each word operation (except for addition modulo 232 ),
it is more efficient to verify the operation when its inputs are represented as separate wires, each
carrying a bit. Thus, CH maintains the 8-word state as 256 individual wires, and the 64-word
message schedule as 64 · 32 wires.
Addition modulo 32. To verify addition modulo 232 we use techniques employed
P31 ini previous
+
work [PGHR13, BCG 13, BCTV14]. Given two words A and B, we compute α := i=0 2 (Ai + Bi ).
16

In practice, one might replace this ECDSA variant with an EC-Schnorr signature satisfying SUF-1CMA security
with proper encoding of EC group elements; the performance would be similar.

23

Because F has characteristic larger than 233 , there is no wrap around; thus, field addition coincides
with integer addition. We then make a non-deterministic
for the 33 bits αi of α (including
P guess
i α . To ensure that each α ∈ {0, 1},
carry), and enforce consistency by requiring that α = 32
2
i
i
i=0
we use a 33-gate subcircuit computing αi (αi − 1), all of which must be 0 for the subcircuit to be
satisfiable. Overall, verifying addition modulo 232 only requires 34 gates. This approach extends in
a straightforward way to summation of more than two terms.
Verifying the SHA256 message schedule. The first 16 words Wi of the message schedule are
the 16 words of the 512-bit input z. The remaining 48 words are computed as Wt := σ1 (Wt−2 ) +
Wt−7 + σ0 (Wt−15 ) + Wt−16 , where σ0 (W ) := rotr7 (W ) ⊕ rotr18 (W ) ⊕ shr3 (W ) and σ1 has the same
structure but different rotation and shift constants.
The rotation and shift amounts are constants, so rotates and shifts can be achieved by suitable
wiring to previously computed bits (or the constant 0 for high-order bits in shr). Thus, since the
XOR of 3 bits can be computed using 2 gates, both σ0 and σ1 can be computed in 64 gates. We
then compute (or more precisely, guess and verify) the addition modulo 232 of the four terms.
Verifying the SHA256 round function. The round function modifies the 8-word state by
changing two of its words and then permuting the 8-word result.
Each of the two modified words is a sum modulo 232 of (i) round-specific constant words Kt ;
(ii) message schedule words Wt ; and (iii) words obtained by applying simple functions to state
words. Two of those functions are bitwise majority (Maj(A, B, C)i = 0 if Ai + Bi + Ci ≤ 1 else 1)
and bitwise choice (Ch(A, B, C)i = Bi if Ai = 1, else Ci ). We verify correct computation of Maj
using 2 gates per output bit, and Ch with 1.
Then, instead of copying 6 unchanged state words to obtain the permuted result, we make the
permutation implicit in the circuit’s wiring, by using output wires of previous sub-computations
(sometimes reaching 4 round functions back) as input wires to the current sub-computation.
Performance. Overall, we obtain an arithmetic circuit CH for verifying SHA256’s compression
function with less than 30 000 arithmetic gates. See Figure 3 for a breakdown of gate counts.
Gate count for CH
Message schedule
8032
All rounds
19 584
1 round (of 64)
306
Finalize
288
Total
27 904
Figure 3: Size of circuit CH for SHA256’s compression function.

Comparison with generic approaches. We constructed the circuit CH from scratch. We could
have instead opted for more generic approaches: implement SHA256’s compression function in
a higher-level language, and use a circuit generator to obtain a corresponding circuit. However,
generic approaches are significantly more expensive for our application, as we now explain.
Starting from the SHA256 implementation in PolarSSL (a popular cryptographic library) [Pol13],
it is fairly straightforward to write a C program for computing H. We wrote such a program, and
gave it as input to the circuit generator of [PGHR13]. The output circuit had 58160 gates, more
than twice larger than our hand-optimized circuit.
Alternatively, we also compiled the same C program to TinyRAM, which is the architecture
supported in [BCG+ 13]; we obtained a 5371-instruction assembly code that takes 5704 cycles to
execute on TinyRAM. We could then invoke the circuit generator in [BCG+ 13] when given this
TinyRAM program and time bound. However, each TinyRAM cycle costs ≈ 1000 gates, so the
resulting circuit would have at least 5.7 · 106 gates, i.e., over 190 times larger than our circuit. A
24

similar computation holds for the circuit generator in [BCTV14], which supports an even more
flexible architecture.
Thus, overall, we are indeed much better off constructing CH from scratch. Of course, this is
not surprising, because a SHA256 computation is almost a “circuit computation”: it does not make
use of complex program flow, accesses to memory, and so on. Thus, relying on machinery developed
to support much richer classes of programs does not pay off.
5.2.2

Arithmetic circuit for POUR

The NP statement POUR requires verifying membership in a Merkle tree based on H, a few additional
invocations of H, and integer addition and comparison. We construct the circuit CPOUR for POUR by
combining various subcircuits verifying each of these. There remains to to discuss the subcircuits
for verifying membership in a Merkle tree (using the aforementioned subcircuit CH for verifying
invocations of H), and integer addition and comparison.
Merkle tree membership. We need to construct an arithmetic circuit that, given a root rt,
authentication path path, and coin commitment cm, is satisfied if and only if path is a valid
authentication path for the leaf cm with respect to the root rt. The authentication path path
includes, for each layer i, an auxiliary hash value hi and a bit ri specifying whether hi was the left
(ri = 0) or the right (ri = 1) child of the parent node. We then check membership in the Merkle
tree by verifying invocations of H, bottom-up. Namely, for d = 64, we set kd−1 = cm; then, for each
i = d − 1, . . . , 1, we set Bi = hi kki if ri = 0 else ki khi , and compute ki−1 = H(Bi ). Finally we check
that the root k0 matches the given root rt.
Integer addition. We need to construct an arithmetic circuit that, given 64-bit integers A, B, C
(presented as binary strings), is satisfied if and only if C = A + B over the integers. Again
P63 relying
i
on
P63the i fact that F’s characteristic is sufficiently large, we do so by checking that i=0 2 ci =
i=0 2 (bi + ai ) over F; this is enough, because there is no wrap around.
Integer comparison. We need to construct an arithmetic circuit that, given two 64-bit integers
A, B (represented in binary),
satisfied ifP
and only if A + B fits in 64 bits (i.e. A + B < 264 ). We
P63 is
i
64 then
do so by checking that i=0 2 (bi + ai ) = 63
i=0 ci for some ci ∈ {0, 1}. Indeed, if A + B < 2
it suffices to take ci as the binary representation
of A + B. However, if A + B ≥ 264 then no choice
P63
64
of ci can satisfy the constraint as i=0 ci ≤ 2 − 1. Overall, this requires 65 gates (1 gate for the
equality check, and 64 gates for ensuring that c0 , . . . , c63 are boolean).
Overall circuit sizes. See Figure 4 for the size of CPOUR . More than 99% of the gates are devoted
to verifying invocations of H.
Gate count for CPOUR
Ensure cmold
is
in
Merkle
tree
1
(1 layer out of 64)
Ensure cmold
2 is in Merkle tree
(1 layer out of 64)
old
Check computation of snold
1 , sn2
old
old
Check computation of apk,1 , apk,2
old
new
new
Check computation of cmold
1 , cm2 , cm1 , cm2
Check computation of h1 , h2
Ensure that v1new + v2new + vpub = v1old + v2old
Ensure that v1old + v2old < 264
Miscellaneous
Total

1 802 304
(28 161)
1 802 304
(28 161)
2 × 27 904
2 × 27 904
4 × 83 712
2 × 27 904
1
65
2384
4 109 330

Figure 4: Size of the circuit CPOUR , which verifies the statement POUR.

25

6

Integration with existing ledger-based currencies

Zerocash can be deployed atop any ledger (even one maintained by a central bank). Here, we briefly
detail integration with the Bitcoin protocol. Unless explicitly stated otherwise, in the following
section when referring to Bitcoin, and its unit of account bitcoin (plural bitcoins), we mean the
underlying protocol and software, not the currency system. (The discussion holds, with little or no
modification, for many forks of Bitcoin, also known as “altcoins”, such as Litecoin.)
By introducing new transaction types and payment semantics, Zerocash breaks compatibility
with the Bitcoin network. While Zerocash could be integrated into Bitcoin (the actual currency and
its supporting software) via a “flag day” where a super-majority of Bitcoin miners simultaneously
adopt the new software, we neither expect nor advise such integration in the near future and suggest
using Zerocash in a separate altcoin.
Integrating Zerocash into Bitcoin consists of adding a new transaction type, Zerocash transactions,
and modifying the protocol and software to invoke Zerocash’s DAP interface to create and verify
these transactions. There are at least two possible approaches to this integration. The first approach
replaces all bitcoins with zerocoins, making all transactions anonymous at the cost of losing any
additional Bitcoin functionality provided by, e.g., the Bitcoin scripting language (see Section 6.1).
The second approach maintains this functionality, adding a parallel Zerocash currency, zerocoin,
which can be converted to and from bitcoin at a one-to-one rate (see Section 6.2). Options for
protocol-level modifications for the later approach are discussed in Section 6.3; the former can be
readily inferred. In Section 6.4 we discuss anonymizing the network layer of Bitcoin and anonymity
safeguards.

6.1

Integration by replacing the base currency

One approach is to alter the underlying system so that all monetary transactions are done using
Zerocash, i.e., by invoking the DAP interface and writing/reading the associated transactions in the
distributed ledger.
As seen in Section 3, this suffices to offer the core functionality of payments, minting, merging,
splitting, etc., while assuring users that all transactions using this currency are anonymous. However,
this has several drawbacks: (1) All pour transactions incur the cost of generating a zk-SNARK proof.
(2) If Bitcoin supports additional features, such as a scripting language for specifying conditions for
claiming bitcoins (as in Bitcoin), then these features are lost.17 (3) Bitcoin allows the flexibility of
spending unconfirmed transactions; instead, with a Zerocash-only Bitcoin, this flexibility is lost:
transactions must be confirmed before they can be spent. (And this imposes a minimal delay
between receiving funds and spending them.)

6.2

Integration by hybrid currency

A different approach is to extend Bitcoin with a parallel, anonymized currency of “zerocoins”,
existing alongside bitcoins, using the same ledger, and with the ability to convert freely between
the two. The behavior and functionality of regular bitcoins is unaltered; in particular, they may
support functionality such as scripting.
In this approach, the Bitcoin ledger consists of Bitcoin-style transactions, containing inputs and
outputs [Nak09]. Each input is either a pointer to an output of a previous transaction (as in plain
Bitcoin), or a Zerocash pour transaction (which contributes its public value, vpub , of bitcoins to
this transaction). Outputs are either an amount and destination public address/script (as in plain
17

However, in principle POUR could be extended to include a scripting language interpreter.

26

Bitcoin), or a Zerocash mint transaction (which consumes the input bitcoins to produce zerocoins).
The usual invariant over bitcoins is maintained and checked in plain view: the sum of bitcoin inputs
(including pours’ vpub ) must be at least the sum of bitcoin outputs (including mints’ v), and any
difference is offered as a transaction fee. However, the accounting for zerocoins consumed and
produced is done separately and implicitly by the DAP scheme.
The life cycle of a zerocoin is as follows.
Creating new zerocoins. A mint transaction consumes v worth of bitcoins as inputs, and outputs
coin commitment worth v zerocoins. The v bitcoins are effectively destroyed, in exchange for the
newly-minted zerocoins.
Spending zerocoins. Zerocoins can then be transferred, split, and merged into other zerocoins
arbitrarily, via pour transactions which, instead of explicit inputs, include zero-knowledge proofs
that such inputs exist. Pour transactions may optionally reveal a non-zero public output vpub . This
is either left unclaimed as a transaction fee,18 placed into a standard Bitcoin transaction output
(e.g., one paying to a public key) or consumed by a mint transaction. Thus, vpub bitcoins are created
ex nihilo (similarly to how coinbase transactions produce bitcoin outputs as mining reward), in
exchange for destroying that amount of zerocoins. The Bitcoin outputs must be included in the
transaction string info, which is included as part of a pour transaction; transaction non-malleability
ensures that all this information is bound together.
Spending multiple zerocoins. To allow for pours to span more than two input and output coins,
txPour structures may be chained together within one transaction by marking some output coin
commitments as intermediates and having subsequent pours in the same transaction constructed
relative to an ephemeral Merkle tree consisting of only the intermediates commitments. For example,
a transaction might accept four input coins, with the first two Pour operations combining two
of the inputs to produce an intermediate commitment each and a final Pour combining the two
intermediate commitments into a final output new coin. Since the intermediate results are consumed
instantly within the transaction, they need not be recorded in the global Merkle tree or have their
serial numbers marked as spent.
Transaction fees. Collecting transaction fees is done as usual, via a coinbase transaction added
to each block, which pays as mining reward the difference between the total inputs (bitcoin and
pours’ vpub ) and total outputs (bitcoin and mints’ v) in this block. Payment is either in bitcoins or
in newly-minted zerocoins (via a Mint).
Validation and block generation. All transactions are verified via VerifyTransaction when they
are received by a node. Any plain Bitcoin inputs and outputs are processed as usual, and any
Zerocash inputs and outputs are checked using VerifyTransaction with the entire Bitcoin transaction
fed in as info for authentication. Once these transactions are assembled into a candidate block, each
transaction needs to be verified again to ensure its serial number has not become spent or its Merkle
root invalid. If these checks pass, the set of new coin commitments and spent serial numbers output
by the included transactions are added to the global sets, and the new Merkle root and a digest of
the serial number list is stored in the new block.19 Embedding this data simplifies statekeeping and
allows nodes to readily verify they have the correct coin list and serial number list. Upon receiving
a candidate block, nodes validate the block is formed correctly with respect to the above procedure.
Receiving payments. In order to receive payments to an address, users may scan the block chain
by running the Receive on every pour transaction. Alternatively they may receive coin information
18

Since transaction fees may potentially be claimed by any node in the network, they represent the sole zerocoin
output that cannot be hidden from public view even in a Zerocash-only system.
19
This can be stored in the coinbase transaction, as certain other data currently is, or in a new field in the block
header.

27

via some out-of-band mechanism (e.g., via encrypted email). The former process is nearly identical
to the one proposed for “stealth addresses” for Bitcoin. In the worst case, scanning the block chain
requires a trial decryption of every ciphertext C. We expect many scenarios to provide explicit
notification, e.g., in interactive purchases where a communication channel already exists from the
payer to the payee. (Implementations may opt to drop the receive mechanism entirely, and require
out-of-band notification, in order to avoid storing the ciphertexts in the block chain.)

6.3

Extending the Bitcoin protocol to support the combined semantics

While the section above describes the life-cycle of a zerocoin and semantics of the system, there
remains the question of how transactions acquire the above necessary semantics. Two implementation
approaches are possible, with different engineering tradeoffs.
The first approach is to extend the protocol and its implementation with hard-coded validation
of Zerocash transactions, reading them from new, designated fields in transactions and running
VerifyTransaction. In this case the zk-SNARK itself effectively replaces the scripting language for
Zerocash transactions.
The second approach is to extend Bitcoin’s scripting language by adding an opcode that
invokes VerifyTransaction, with the requisite arguments embeded alongside the opcode script. Such
transactions must be exempt from the requirement they reference an input (as they are Zerocash
transactions are self-contained), and, like coinbase transactions, be able to create bitcoins ex nihilo
(to account for vpub ). Moreover, while VerifyTransaction is run at the standard point in the Bitcoin
transaction processing flow for evaluating scripts, the coin commitments and spent serial numbers
are not actually added to CMList (resp., SNList) until their containing block is accepted (i.e., merely
verifying a transaction does not have side effects).

6.4

Additional anonymity considerations

Zerocash only anonymizes the transaction ledger. Network traffic used to announce transactions,
retrieve blocks, and contact merchants still leaks identifying information (e.g., IP addresses). Thus
users need some anonymity network to safely use Zerocash. The most obvious way to do this is
via Tor [DMS04]. Given that Zerocash transactions are not low latency themselves, Mixnets (e.g.,
Mixminion [DDM03]) are also a viable way to add anonymity (and one that, unlike Tor, is not as
vulnerable to traffic analysis). Using mixnets that provide email-like functionality has the added
benefit of providing an out-of-band notification mechanism that can replace Receive.
Additionally, although in theory all users have a single view of the block chain, a powerful
attacker could potentially fabricate an additional block solely for a targeted user. Spending any
coins with respect to the updated Merkle tree in this “poison-pill” block will uniquely identify the
targeted user. To mitigate such attacks, users should check with trusted peers their view of the
block chain and, for sensitive transactions, only spend coins relative to blocks further back in the
ledger (since creating the illusion for multiple blocks is far harder).

7

Experiments

To measure the performance of Zerocash, we ran several experiments. First, we benchmarked the
performance of the zk-SNARK for the NP statement POUR (Section 7.1) and of the six DAP scheme
algorithms (Section 7.2). Second, we studied the impact of a higher block verification time via a
simulation of a Bitcoin network (Section 7.3).

28

7.1

Performance of zk-SNARKs for pouring coins

Our zk-SNARK for the NP statement POUR is obtained by constructing an arithmetic circuit CPOUR
for verifying POUR, and then invoking the generic implementation of zk-SNARK for arithmetic
circuit satisfiability of [BCTV14] (see Section 2.4). The arithmetic circuit CPOUR is built from scratch
and hand-optimized to exploit nondeterministic verification and the large field characteristic (see
Section 5.2) .
Figure 5 reports performance characteristics of the resulting zk-SNARK for POUR. This includes
three settings: single-thread performance on a laptop machine; and single-thread and multi-thread
performance on a desktop machine. (The time measurements are the average of 10 runs, with
standard deviation under 2.5%.) For instance, with single-thread code on the laptop machine, we
obtain that:
• Key generation takes 7 min 48 s, and results in a proving key pkPOUR of 896 MiB and a verification
key vkPOUR of 749 B. This is performed only once, as part of the Setup algorithm.
• Producing a proof πPOUR requires about 3 minutes; proofs have a constant size of 288 B. Proof
generation is a subroutine of the Pour algorithm, and the resulting proof is included in the
corresponding pour transaction.
• A proof πPOUR can be verified in only 8.5 ms. Proof verification is a subroutine of the VerifyTransaction
algorithm, when it is given as input a pour transaction to verify.

KeyGen

Prove
Verify

Time
Proving key
Verification key
Time
Proof
Time

Intel
Core i7-2620M
@ 2.70GHz
12GB of RAM
1 thread
7 min 48 s

2 min 55 s
8.5 ms

Intel
Core i7-4770
@ 3.40GHz
16GB of RAM
1 thread
4 threads
5 min 11 s 1 min 47 s
896 MiB
749 B
1 min 59 s
46 s
288 B
5.4 ms

Figure 5: Performance of our zk-SNARK for the NP statement POUR. (N = 10, σ ≤ 2.5%)

7.2

Performance of Zerocash algorithms

In Figure 6 we report performance characteristics for each of the six DAP scheme algorithms in
our implementation (single-thread on our desktop machine). For VerifyTransaction, we separately
report the cost of verifying mint and pour transactions and, in the latter case, we exclude the cost
of scanning L (e.g., to check if a serial number is duplicate);20 for the case of Receive, we report the
cost to process a given pour transaction in L.
We obtain that:
• Setup takes about 5 minutes to run; its running time is dominated by the running time of KeyGen
on CPOUR . (Either way, Setup is run only once.) The size of the resulting public parameters pp is
dominated by the size of pkPOUR .
• CreateAddress takes 326.0 ms to run. The size of the resulting address key pair is just a few
hundred bytes.
20

Naturally, if SNList has 264 serial numbers (the maximum possible in our implementation), then scanning is very
expensive! However, we do not expect that a system like Zerocash will grow to 264 transactions. Still, such a system
may grow to the point that scanning SNList is too expensive. We detail possible mitigations to this in Section 8.3.2.

29

• Mint takes 23 µs to run. It results in a coin of size 463 B and mint transaction of size 72 B.
• Pour takes about 2 minutes to run. Besides Setup, it is the only “expensive” algorithm to run; as
expected, its running time is dominated by the running time of Prove. For a transaction string
info, it results in (two new coins and) a pour transaction of size 996 B + |info|.
• VerifyTransaction takes 8.3 µs to verify a mint transaction and 5.7 ms to verify a pour transaction;
the latter’s time is dominated by that of Verify, which checks the zk-SNARK proof πPOUR .
• Receive takes 1.6 ms per pour transaction.
Note that the above numbers do not include the costs of maintaining the Merkle tree because
doing so is not the responsibility of the DAP scheme algorithms. Nevertheless, these additional
costs are not large: (i) each update of the root of the CRH-based Merkle tree only requires dtree
invocations of CRH, and (ii) an authentication path consists of only dtree digests of CRH. In our
implementation, where CRH = H (the SHA256 compression function) and dtree = 64, each update
requires 64 invocations of H and an authentication path requires 64 · 32 B = 2 KiB of storage.
Remark. If one does not want to rely on the ledger to communicate coins, via the ciphertexts
C1 , C2 , and instead rely instead on some out-of-band mechanism (e.g., encrypted email), then the
Receive algorithm is not needed, and moreover, many of the aforementioned sizes decrease because
some pieces of data are not needed anymore; we denoted these pieces of data with “?” in Figure 6.
(E.g., the size of an address key pair is reduced to only 64 B, and the size of a coin to only 120 B.)

7.3

Large-scale network simulation

Because Bitcoin mining typically takes place on dedicated GPUs or ASICs, the CPU resources to
execute the DAP scheme algorithms are often of minimal consequence to network performance.
There is one potential exception to this rule: the VerifyTransaction algorithm must be run by all of
the network nodes in the course of routine transaction validation. The time it takes to perform this
verification may have significant impact on network performance.
In the Zerocash implementation (as in Bitcoin), every Zerocash transaction is verified at each hop
as it is forwarded though the network and, potentially, again when blocks containing the transaction
are verified. Verifying a block consists of checking the proof of work and validating the contained
transactions. Thus Zerocash transactions may take longer to spread though the network and blocks
containing Zerocash transactions may take longer to verify. While we are concerned with the first
issue, the potential impact of the second issue is cause for greater concern. This is because Zerocash
transactions cannot be spent until they make it onto the ledger.
Because blocks are also verified at each hop before they are forwarded through the network,
delays in block verification slow down the propagation of new blocks through the network. This
causes nodes to waste CPU-cycles mining on out-of-date blocks, reducing the computational power
of the network and making it easier to mount a “51% attack” (dishonest majority of miners) on the
distributed ledger.
It is a priori unclear whether this potential issue is a real concern. Bitcoin caches transaction
verifications, so a transaction that was already verified when it propagated through the network need
not be verified again when it is seen in a block. The unknown is what percentage of transactions in
a block are actually in any given node’s cache. We thus conduct a simulation of the Bitcoin network
to investigate both the time it takes Zerocash transactions to make it onto the ledger and establish
the effects of Zerocash transactions on block verification and propagation. We find that Zerocash
transactions can be spent reasonably quickly and that the effects of increased block validation time
are minimal.

30

Setup

CreateAddress

Mint

Intel
Core i7-4770
@ 3.40GHz
16GB of RAM
1 thread
5 min 17 s
896 MiB

Time
Size of pp
size of pkPOUR
size of vkPOUR
? size of ppenc
size of ppsig

896 MiB
749 B
0B
0B

Time
Size of addrpk

326.0 ms
343 B

size of apk
? size of pkenc

32 B
311 B

Size of addrsk

319 B

size of ask
? size of skenc

32 B
287 B

Time
Size of coin c

23 µs
463 B

size
size
size
size
size
size

of
of
of
of
of
of

addrpk
v
ρ
r
s
cm

343 B
8B
32 B
48 B
0B
32 B

Size of txMint
size
size
size
size

Pour

of
of
of
of

72 B

cm
v
k
s

32 B
8B
32 B
0B

Time
Size of txPour

2 min 2.01 s
996 B + |info|

size of rt
old
size of snold
1 , sn2
new
size of cmnew
,
cm
1
2
size of vpub
size of info
size of pksig
size of h1 , h2
size of πPOUR
? size of C1 , C2
size of σ

VerifyTransaction
Receive

Time for mint tx
Time for pour tx (excludes L scan)
Time (per pour tx)

32 B
2 × 32 B
2 × 32 B
8B
|info|
66 B
2 × 32 B
288 B
2 × 173 B
64 B

8.3 µs
5.7 ms
1.6 ms

Figure 6: Performance of Zerocash algorithms. Above, we report the sizes of ppenc and ppsig as 0 B, because
these parameters are “hardcoded” in the libraries we rely on for Enc and Sig. (N = 10 with σ ≤ 2.5% for
all except that, due to variability at short timescales, σ(Mint) ≤ 3.3 µs and σ(VerifyTransaction) ≤ 1.9 µs)

Simulation design. Because Zerocash requires breaking changes to the Bitcoin protocol, we
cannot test our protocol in the live Bitcoin network or even in the dedicated testnet. We must run
our own private testnet. For efficiency and cost reasons, we would like to run as many Bitcoin nodes
as possible on the least amount of hardware. This raises two issues. First, reducing the proof of
work to practical levels while still preserving a realistic rate of new blocks is difficult (especially on

31

virtualized hardware with variable performance). Second, the overhead of zk-SNARK verification
prevents us from running many Bitcoin nodes on one virtualized server.
The frequency of new blocks can be modeled as a Poisson process with a mean of Λblock seconds.21
To generate blocks stochastically, we modify bitcoind to fix its block difficulty at a trivial level 22
and run a Poisson process, on the simulation control server, which trivially mines a block on a
randomly selected node. This preserves the distribution of blocks, without the computational
overhead of a real proof of work. Another Poisson process triggering mechanism, with a different
mean Λtx , introduces new transactions at random network nodes.
To differentiate which transactions represent normal Bitcoin expenditures versus which contain
Zerocash pour transactions, simulated Zerocash transactions pay a unique amount of bitcoins (we
set this value arbitrarily at 7 BTC). If a transaction’s output matches this preset value, and it is not
in verification cache, then our modified Bitcoin client inserts a 10 ms delay simulating the runtime
of VerifyTransaction.23 Otherwise transactions are processed as specified by the Bitcoin protocol.
We vary the amount of simulated Zerocash traffic by varying the number of transactions with this
particular output amount. This minimizes code changes and estimates only the generic impact of
verification delays and not of any specific implementation choice.
Methodology. Recent research [DW13] suggests that the Bitcoin network contains 16,000 distinct
nodes though most are likely no longer participating: approximately 3,500 are reachable at any
given time. Each node has an average of 32 open connections to randomly selected peers. As of
November 2013, the peak observed transaction rate for Bitcoin is slightly under one transaction per
second [Lee13].
In our simulation, we use a 1000-node network in which each node has an average of 32 peers,
transactions are generated with a mean of Λtx = 1 s, a duration of 1 hour, and a variable percentage
 of Zerocash traffic. To allow for faster experiments, instead of generating a block every 10 minutes
as in Bitcoin, we create blocks at an average of every Λblock = 150 s (as in Litecoin, a popular
altcoin).
We run our simulation for different traffic mixes, where  indicates the percentage of Zerocash
transactions and  ∈ {0%, 25%, 50%, 75%, 100%}. Each simulation is run on 200 Amazon EC2
general-purpose m1.medium instances, in one region on a 10.10./16 private network. On each
instance, we deploy 5 instances of bitcoind.24
Results. Transactions are triggered by a blocking function call on the simulation control node
that must connect to a random node and wait for it to complete sending a transaction. Because
the Poisson process modeling transactions generates delays between such calls and not between the
exact points when the node actuals sends the transactions, the actual transaction rate is skewed.
In our experiments the real transaction rate shifts away from our target of one per second to an
average of one every 1.4 seconds.
In Figure 7 we plot three metrics for  ∈ {0%, 25%, 50%, 75%, 100%}. Each is the average
defined over the data from the entire run of the simulation for a given  (i.e., they include multiple
transactions and blocks).25 Transaction latency is the interval between a transaction’s creation and
21
Since computational power is added to the Bitcoin network faster than the 2-week difficulty adjustment period,
the frequency of block generation is actually skewed. As our experiments run for at most an hour, we ignore this.
22
These code modifications have been rendered moot by the subsequent inclusion of a “regtest” mode in Bitcoin 0.9
that allows for precisely this type of behavior and block generation on command. At the time of our experiments, this
feature was not available in a stable release. Future work should use this feature.
23
We used a generous delay of 10 ms (higher than the time reported in Figure 6) to leave room for machines slower
than our desktop machine.
24
Higher densities of nodes per VM resulted in issues initializing all of the bitcoind instances on boot.
25
Because our simulated Bitcoin nodes ran on shared EC2 instances, they were subject to variable external load,

32

its inclusion in a block. Block propagation time comes in two flavors: (1) the average time for a new
block to reach a node computed over the times for all nodes, and (2) the same average computed
over only the last node to see the block.
Block verification time is the average time, over all nodes, required to verify a block. If verification
caching was not effective, we would expect to see a marked increase in both block verification time
and propagation time. Since blocks occur on average every 150 s, and we expect approximately
one transaction each second, we should see 150 × 10 ms = 1500 ms of delay if all transactions were
non-cached Zerocash transactions. Instead, we see worst case 80 ms and conclude caching is effective.
This results in a negligible effect on block propagation (likely because network operations dominate).
The time needed for a transaction to be confirmed, and hence spendable, is roughly 190 s. For
slower block generation rates (e.g., Bitcoin’s block every 10 minutes) this should mean users must
wait only one block before spending received transactions.
200

4.5

80

180

4

70

160

3.5

120
100
80
60

3
2.5
2
1.5

40

1

20

0.5

0
0%

Zerocash
20%

40%

60%

80%

100%

60

time in milliseconds

time in seconds

time in seconds

140

40
30
20

0
0%

10

last node
every node
20%

40%

ε

(a) Transaction latency

50

60%

80%

ε

(b) Block propagation time

100%

0
0%

Zerocash
20%

40%

60%

80%

100%

ε

(c) Block verification time

Figure 7: The average values of the three metrics we study, as a function of , the percentage of transactions
that are Zerocash transactions. Note that, in (a), latency is undefined when  = 0 and hence omitted.

8

Optimizations and extensions

We outline several optimizations and extensions to Zerocash: everlasting anonymity (Section 8.1),
faster block propagation (Section 8.2), and improved storage requirements (Section 8.3).

8.1

Everlasting anonymity

Since transactions may persist virtually forever on the ledger, users may wish to ensure the
anonymity of their transactions also lasts forever, even if particular primitives are eventually broken
(by cryptanalytic breakthrough, engineering progress, or quantum computers). As we now explain,
the DAP scheme construction described in Section 4 is only computationally private, but can be
modified to achieve everlasting anonymity.
old
new
new
Recall that every Pour operation publishes a pour transaction txPour = (rt, snold
1 , sn2 , cm1 , cm2 ,
new
new , snew )).
vpub , info, ∗), where ∗ = (pksig , h1 , h2 , πPOUR , C1 , C2 , σ) and Ci = Eenc (pkenc,i , (vinew , ρnew
i , ri
i
Observe that:
limiting the benchmark precision. Still, it clearly demonstrates that the mild additional delay does not cause
catastrophic network effects.

33

• Since hSig = CRH(pksig ) and hi = PRFpk
(hSig ), an unbounded adversary A can iterate over all x
aold
sk,i

until PRFpk
x (hSig ) equals hi ; with overwhelming probability, there is only one such x, in which
addr
old
old
case it equals aold
sk,i . Thus, A learns ask,i , and hence apk,i := PRFaold (0). This identifies the sender.
sk,i

new , snew ); then, A can try all
• An unbounded A can also decrypt Ci , so to learn (vinew , ρnew
i , ri
i
addr
new kCOMM new (PRF
new )) equals cmnew ; with overwhelming
possible x until COMMsnew
(v
(0)kρ
r
x
i
i
i
i
i
probability, there is only one such x, in which case it equals anew
.
This
identifies
the recipient.
sk,i

The above attacks can be prevented as follows. First, every sender must use any given address
only once (for receiving or sending coins): after receiving a coin c, a user u should immediately
generate a new address and pour c into a fresh one c0 relative to the new address; only afterwards
can u spend the coin. Second, a user should not put any data in a ciphertext Ci to communicate
a coin’s information, but must instead use some (informationally-secure) out-of-band channel to
do so. With these modifications (and recalling that COMM is statistically hiding and πPOUR is a
perfect-zero-knowledge proof), one can verify that the pour transaction txPour is statistically hiding,
i.e., leaks no information even to unbounded adversaries.26

8.2

Fast block propagation

As mentioned in Section 7.3, the higher block-verification time of Zerocash compared to, e.g., Bitcoin
does not affect much block propagation. Even so, we note a simple modification that further mitigates
concerns. Upon receiving a block, a node validates the proof of work and (optionally) transactions
other than mint and pour, and then forward the block right away. Only afterwards, the node
executes VerifyTransaction on any mint/pour transactions, before accepting it for use in transacting.
Thus, blocks are still validated by every node (so the security properties are unhampered), and
propagation delays in the broadcast of blocks are reduced.
In principle, this opens the possibility of a denial-of-service attack, in which the network is
spammed with invalid blocks which pass the proof-of-work check but contain invalid mint or pour
transactions. However, this attack appears unrealistic given the enormous (by design) cost of
creating blocks passing the proof-of-work check.

8.3

Improved storage requirements

Beyond the ledger L, users need to maintain two lists: CMList, the list of all coin commitments,
and SNList, the list of all serial numbers of spent coins (see Section 3.1). In our construction,
CMList is required to deduce authentication paths to create new pour transactions (via Pour), while
SNList is used to verify pour transactions (via VerifyTransaction). As the ledger grows, both CMList
and SNList grow in size, and can eventually impose substantial storage requirements (though both
are derived from, and smaller than, the block chain per se). We now explain how these storage
requirements can be mitigated, by relying on smaller representations of CMList and SNList that
suffice within our construction.
8.3.1

Supporting many coin commitments

To execute the Pour algorithm to spend a coin c, a user u needs to provide an authentication path
from c’s coin commitment to rt, the Merkle-tree root over CMList. If we make the following protocol
modifications, u does not need all of CMList to compute this authentication path.
26

As for mint transactions, one can verify that they are already statistically hiding, without any modifications.

34

In each block B of transactions, we store the Merkle-tree path pathB from the first coin
commitment in B to the root rtB of the Merkle tree over CMList when the last block in the ledger
is B. (In Zerocash, the additional per-block storage cost to store this information is only 2 KiB.)
Note that, given a block B and its successor block B 0 , the corresponding authentication paths
pathB and pathB 0 can be easily checked for consistency as follows. Let CMListB and CMListB 0 be
the two lists of coin commitments corresponding to the two ledgers ending in block B and B 0
respectively; since CMListB (i.e., coin commitments to “to the left” of pathB ) is a prefix of CMListB 0 ,
pathB 0 can be computed from pathB and B in time O(|B|dtree ), where dtree is the tree depth.
When the user u first receives (or mints) the coin c, and its coin commitment is included in a
block B, u immediately computes pathB , by using the predecessor block and its authentication path.
Afterwards, each time a new block is added to the ledger, u obtains a new path for c by using the
new block and the old path for c. Thus, u only needs to act each time a new block is added, and
each such update costs O(dtree ) per transaction in the block.
Overall, u incurs a storage requirement of only O(dtree ) for each coin he owns, and does not
need to store CMList anymore.
8.3.2

Supporting many spent serial numbers

To execute the VerifyTransaction algorithm on a pour transaction txPour , a user u needs access to
SNList (in order to check for duplicate serial numbers). Note, in Bitcoin, nodes need to maintain
only the list of unspent transaction outputs, which is pruned as outputs are spent. In a DAP scheme,
in contrast, nodes have to maintain SNList, which is a list that always grows. We now explain how
to mitigate this storage requirement, in three incremental steps.
Step 1. The first step is to build a Merkle tree over SNList so to allow easy-to-verify non-membership
proofs for SNList; this can be done by letting the leaves of the Merkle tree be the intervals of unspent
serial numbers. Then, given the root rt of such tree, a serial number sn claimed to be unspent, and
an authentication path path for an interval I, the user can check that path is valid for rt and that
sn lies in I; the root rt and path path would be part of the pour transaction txPour to be verified.
The problem with this approach, however, is that generating path (and also updating rt) requires
knowledge of all of SNList.
Step 2. Next, instead of maintaining SNList in a single Merkle tree, we divide SNList, maintaining
its chronological order, into sublists of serial numbers SNList0 , SNList1 , . . . and build a Merkle tree
over the intervals induced by each sublist (i.e., apply Step 1 to each sublist). This modification
implies a corresponding modification for the auxiliary information stored in a pour transaction
that allows VerifyTransaction to check it. Now, however, producing such auxiliary information
is less expensive. Indeed, a user with a coin c should maintain a list of authentication paths
pathc,0 , pathc,1 , . . . (one for each sublist). Only the last path, corresponding to the active sublist,
needs to be updated when a serial number is added; the other sublists and authentication paths
remain unchanged (and these old sublists can in fact be discarded). When the user spends the coin,
he can simply include these paths in the pour transaction. While updating these paths is an efficient
operation, computing the initial paths for c is not, as it still requires the full set of sublists.
Step 3. To enable users to avoid the initial cost of computing paths for a new coin, we proceed
as follows. First, a coin c is extended to contain a time stamp Tc corresponding to when c is
created (minted or poured into); the coin’s commitment is modified to depend on the timestamp,
and the timestamp is included in the clear within the transaction that creates the coin. Then, a
user, upon spending c, produces a zk-SNARK for the following NP statement: “for each Merkle-tree
root created (or updated) after Tc there is an interval and an authentication path for that interval

35

such that the serial number of c is in that interval”. Depending on the number of Merkle trees in
such an NP statement, such proofs may already be more efficient to produce, compared to the naive
(Step 1) solution, using existing zk-SNARK implementations.

9

Concurrent work

Danezis et al. [DFKP13] suggest using zk-SNARKs to reduce proof size and verification time in
Zerocoin. Our work differs from [DFKP13] in both supported functionality and scalability.
First, [DFKP13]’s protocol, like Zerocoin, only supports fixed-value coins, and is best viewed
as a decentralized mix. Instead, we define, construct, and implement a full-fledged decentralized
electronic currency, which provides anonymous payments of any amount.
Second, in [DFKP13], the complexity of the zk-SNARK generator, prover, and verifier all scale
superlinearly in the number of coins, because their arithmetic circuit computes, explicitly, a product
over all coins. In particular, the number of coins “mixed together” for anonymity cannot be large.
Instead, in our construction, the respective complexities are polylogarithmic, polylogarithmic, and
constant in the number of coins; our approach supports a practically-unbounded number of coins.
While we do not rely on Pedersen commitments, our approach also yields statistical (i.e.,
everlasting) anonymity; see the discussion in Section 8.1.

10

Conclusion

Decentralized currencies should ensure a user’s privacy from his peers when conducting legitimate
financial transactions. Zerocash provides such privacy protection, by hiding user identities, transaction amounts, and account balances from public view. This, however, may be criticized for
hampering accountability, regulation, and oversight. Yet Zerocash need not be limited to enforcing
the basic monetary invariants of a currency system. The underlying zk-SNARK cryptographic proof
machinery is flexible enough to support a wide range of policies. It can, for example, let a user prove
that he paid his due taxes on all transactions without revealing those transactions, their amounts, or
even the amount of taxes paid. As long as the policy can be specified by efficient nondeterministic
computation using NP statements, it can (in principle) be enforced using zk-SNARKs, and added
to Zerocash. This can enable automated, privacy-preserving verification and enforcement of a wide
range of compliance and regulatory policies that would otherwise be invasive to check directly or
might be bypassed by corrupt authorities. This raises research, policy, and engineering questions
regarding which such policies are desirable and practically realizable.
Another research question is what new functionality can be realized by augmenting the capabilities
already present in Bitcoin’s scripting language with zk-SNARKs that allow fast verification of
expressive statements.

36

Acknowledgments
We thank Amazon for their assistance and kind donation of EC2 resources, and Gregory Maxwell for
his advice regarding the Bitcoin codebase. We thank Iddo Ben-Tov and the SCIPR Lab members
— Daniel Genkin, Lior Greenblatt, Shaul Kfir, Gil Timnat, and Michael Riabzev — for inspiring
discussions. We thank Sharon Kessler for editorial advice.
This work was supported by: Amazon.com through an AWS in Education research grant; the
Broadcom Foundation and Tel Aviv University Authentication Initiative; the Center for Science of
Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370;
the Check Point Institute for Information Security; the U.S. Defense Advanced Research Projects
Agency (DARPA) and the Air Force Research Laboratory (AFRL) under contract FA8750-11-2-0211;
the European Community’s Seventh Framework Programme (FP7/2007-2013) under grant agreement
number 240258; the Israeli Centers of Research Excellence I-CORE program (center 4/11); the Israeli
Ministry of Science and Technology; the Office of Naval Research under contract N00014-11-1-0470;
the Simons Foundation, with a Simons Award for Graduate Students in Theoretical Computer
Science; and the Skolkovo Foundation with agreement dated 10/26/2011.
The views expressed are those of the authors and do not reflect the official policy or position of the
Department of Defense or the U.S. Government.

37

A

Overview of Bitcoin and Zerocoin

We provide an overview of the Bitcoin and Zerocoin protocols. For more details, we refer the reader
to Nakamoto [Nak09] and Miers et al. [MGGR13] respectively.

A.1

Bitcoin

Bitcoin [Nak09] is a decentralized currency operated by a collection of mutually-distrusting peers.
It consists of three basic components: (i) a peer-to-peer network for broadcasting new transactions;
(ii) semantics for identifying and validating new transactions; and (iii) a protocol for maintaining a
decentralized ledger, known as the block chain, that stores the history of all valid transactions so far.
Identities in Bitcoin are represented via ECDSA public keys. Each user u generates an ECDSA
key pair (vku , sku ) and, to receive payments, publishes the verification key vku (or its hash) as an
address. (In fact, there is no limit to the number of addresses that an individual user may possess.)
Transactions. A transaction tx represents a payment from a list of input transactions to a list of
output recipients. More precisely, tx is specified by a list {Ij }j of inputs and a list {Oj }j of outputs.
Each output Oj specifies a value vj , denominated in Satoshi (109 Satoshi amounts to 1 bitcoin), and
a recipient specification rj , called ScriptPubKey. The specification rj is given in Bitcoin script, a
stack-based non-Turing-complete language similar to Forth, and specifies the identity of the recipient
of the vj Satoshi. Each input Ij references an output of a previous transaction txj : the reference is
specified by a tuple (hj , kj , σj ), where hj is the hash of txj , kj is an index specifying which output of
txj is referenced, and σj , called ScriptSig, is a an input satisfying the ScriptPubKey of the kj -th
output of txj . Typically, the ScriptPubKey specifies a public key that must sign the transaction
spending the output and σj contains such a signature, hence their names. Inputs can only be
claimed by one transaction to prevent double spending. P
The total number of bitcoins output by a transaction, j vj , cannot exceed the total value of
the referenced outputs. Any difference between these two quantities is claimed as a transaction fee
(see below). Thus, any unspent inputs to a transaction become a fee, and transactions typically
have at least two outputs: one to the payment’s recipient and one back to the sender as “change”.
The block chain. Transactions are broadcast in the Bitcoin peer-to-peer network, but are
considered valid only once they have been added to the the block chain. To assemble the block
chain, miners (usually but not necessarily, network nodes) collect transactions from the Bitcoin
network and bundle them into blocks. Miners then compete for the opportunity to append their
own candidate block B to the block chain by searching for a string s such that the integer specified
by SHA256(SHA256(Bks)) is below some threshold. To incentivize block creation, miners receive
a protocol-specified reward (currently 25 BTC) for adding a new block and, moreover, receive
per-transaction fees (whose value is specified by the transaction’s creator).
The proof of work protects a block against tampering and also ensures that meaningful computational resources were devoted to finding it. This prevents a sybil attack since all the sybils share
the same total computational resources (e.g., the server they are virtualized on). Bitcoin assumes
that provided more than half the computational work is held by honest nodes, the block-chain is
secure. (Though recent work [ES13] has suggested that the threshold may be larger than 50%.)

A.2

Zerocoin

Zerocoin extends Bitcoin by creating two new transaction types: mint and spend. A mint transaction
allows a user to exchange a quantity of bitcoins for the right to mint a new zerocoin. Each zerocoin
consists of a digital commitment cm to a random serial number sn. At a later point, a (potentially
38

different) user may issue a spend transaction containing a destination identity, the serial number
sn, and a non-interactive zero-knowledge proof for the NP statement “I know secret cm and r
such that (i) cm can be opened to sn with commitment randomness r, and (ii) cm was previously
minted at some point in the past”. Crucially, the proof, being zero knowledge, does not link the
spend transaction to any particular mint transaction (among all mint transactions so far). If the
proof verifies correctly and the serial number has not been spent previously, the protocol semantics
transfer a corresponding amount of bitcoins to the destination address. In this fashion, Zerocoin
functions as a decentralized mix.
Zerocoin uses Pedersen commitments over a prime field Fp , i.e., cm := g sn hr , for random
generators g, h of a subgroup of F∗p . The corresponding zero-knowledge proofs are constructed
by first accumulating (via the Strong-RSA accumulator of [CL01]) the set of commitments of all
minted zerocoins, and then proving knowledge of the corresponding commitment randomness and
membership in this set. For technical reasons, the proof requires a double-discrete-logarithm (DDL)
Fiat–Shamir proof of size ≈ |p|λ, where λ is the security parameter. In practice, the size of these
proofs exceeds 45 kB at the 128-bit security level, and require 450 ms or more to verify.
Also note that, in Zerocoin, computing the witness for the accumulator requires access to
the entire set of commitments so far (though the witness can be incrementally updated for each
insertion). This technique supports an unlimited number of coins. In contrast, our construction
places a cap N on the number of coins (in our implementation, N = 264 ) but needs only log N
updates to issue N new coins (and these updates can be efficiently batched, cf. Section 8.3.1).

B

Completeness of DAP schemes

A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) is complete if no
polynomial-size ledger sampler S can win the incompleteness experiment with more than negligible
probability. In Section 3.4 we informally described this property; we now formally define it.
Definition B.1. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candidate) DAP scheme. We say that Π is complete if, for every poly(λ)-size ledger sampler S and
sufficiently large λ,
AdvINCOMP
(λ) < negl(λ) ,
Π,S
where AdvINCOMP
(λ) := Pr[INCOMP(Π, S, λ) = 1] is S’s advantage in the incompleteness experiment.
Π,S
We now describe the incompleteness experiment mentioned above. Given a (candidate)
DAP scheme Π, a ledger sampler S, and a security parameter λ, the (probabilistic) experiment
INCOMP(Π, S, λ) consists of an interaction between S and a challenger C, terminating with a binary
output by C.
At the beginning of the experiment, C samples pp ← Setup(1λ ) and sends pp to S. Then, S
sends C a ledger, two coins to be spent, and parameters for a pour transaction; more precisely, S
old
old
old
sends (1) a ledger L; (2) two coins cold
1 , c2 ; (3) two address secret keys addrsk,1 , addrsk,2 ; (4) two
new
new
new
values v1new , v2new ; (5) new address key pairs (addrnew
pk,1 , addrsk,1 ), (addrpk,2 , addrsk,2 ); (6) a public value
vpub ; and (7) a transaction string info. Afterwards, C performs various checks on S’s message.
old
old
Concretely, C first checks that cold
1 and c2 are valid unspent coins, i.e., checks that: (i) c1
old
old
old
and c2 are well-formed; (ii) their coin commitments cm1 and cm2 appear in (valid) transactions
old
on L; (iii) their serial numbers snold
1 and sn2 do not appear in (valid) transactions on L. Next, C
checks that v1new + v2new + vpub = v1old + v2old (i.e., the values suggested by S preserve balance) and
v1old + v2old ≤ vmax (i.e., the maximum value is not exceeded). If any of these checks fail, C aborts
and outputs 0.
39

Otherwise, C computes rt, the Merkle-tree root over all coin commitments in L (appearing in
valid transactions), and, for i ∈ {1, 2, }, pathi , the authentication path from commitment cmold
i to
old as instructed by S:
the root rt. Then, C attempts to spend cold
,
c
1
2
old
old
new
new
new
old old
new new
(cnew
1 , c2 , txPour ) ← Pour(pp, rt, c1 , c2 , addrsk,1 , addrsk,2 , path1 , path2 , v1 , v2 , addrpk,1 , addrpk,2 , vpub , info) .

Finally, C outputs 1 if and only if any of the following conditions hold:
old
new
new
new
new are the coin commitments
• txPour 6= (rt, snold
1 , sn2 , cm1 , cm2 , vpub , info, ∗), where cm1 , cm2
new
new
of c1 , c2 ; OR
• txPour is not valid, i.e., VerifyTransaction(pp, txPour , L) outputs 0; OR
new
0
0
• for some i ∈ {1, 2}, the coin cnew
is not returned by Receive(pp, (addrnew
pk,i , addrsk,i ), L ), where L
i
is the ledger obtained by appending txPour to L.
Remark. There is no need for the challenger C check that, in turn, both cnew
and cnew
are spendable,
1
2
new
new
because this follows by induction. Namely, if c1 , c2 were not spendable, a different sampler S 0
(that simulates S and then computes and outputs cnew
and cnew
1
2 ) would provide a counterexample
to the above definition.

C

Security of DAP schemes

A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) is secure if it satisfies ledger indistinguishability, transaction non-malleability, and balance. (See Definition 3.2.) In
Section 3.4 we informally described these three properties; we now formally define them.
Each of the definitions employs an experiment involving a (stateful) DAP oracle ODAP that
receives and answers queries from an adversary A (proxied via a challenger C, which performs the
experiment-specific sanity checks). Below, we first describe how ODAP works.
The oracle ODAP is initialized by a list of public parameters pp and maintains state. Internally,
ODAP stores: (i) L, a ledger; (ii) ADDR, a set of address key pairs; (iii) COIN, a set of coins. All of
L, ADDR, COIN start out empty. The oracle ODAP accepts different types of queries, and each query
causes different updates to L, ADDR, COIN and outputs. We now describe each type of query Q.
• Q = (CreateAddress)
1. Compute (addrpk , addrsk ) := CreateAddress(pp).
2. Add the address key pair (addrpk , addrsk ) to ADDR.
3. Output the address public key addrpk .
The ledger L and coin set COIN remain unchanged.
• Q = (Mint, v, addrpk )
1.
2.
3.
4.

Compute (c, txMint ) := Mint(pp, v, addrpk ).
Add the coin c to COIN.
Add the mint transaction txMint to L.
Output ⊥.

The address set ADDR remains unchanged.
old
old
old
new
new
new new
• Q = (Pour, idxold
1 , idx2 , addrpk,1 , addrpk,2 , info, v1 , v2 , addrpk,1 , addrpk,2 , vpub )

1. Compute rt, the root of a Merkle tree over all coin commitments in L.
2. For each i ∈ {1, 2}:
old
(a) Let cmold
i be the idxi -th coin commitment in L.
40

3.
4.
5.
6.
7.
8.

(b) Let txi be the mint/pour transaction in L that contains cmold
i .
old
(c) Let ci be the first coin in COIN with coin commitment cmold
i .
old
old
old
)
be
the
first
key
pair
in
ADDR
with
addr
,
addr
(d) Let (addrold
pk,i being ci ’s address.
sk,i
pk,i
(e) Compute pathi , the authentication path from cmold
i to rt.
new , tx
old , cold , addrold , addrold , path , path , v new , v new ,
Compute (cnew
,
c
)
:=
Pour(pp,
rt,
c
Pour
1
2 1
sk,1
sk,2
1
2
1
2
2
new
addrnew
pk,1 , addrpk,2 , vpub , info).
Verify that VerifyTransaction(pp, txPour , L) outputs 1.
Add the coin cnew
to COIN.
1
new
Add the coin c2 to COIN.
Add the pour transaction txPour to L.
Output ⊥.

If any of the above operations fail, the output is ⊥ (and L, ADDR, COIN remain unchanged).
• Q = (Receive, addrpk )
1.
2.
3.
4.

Look up (addrpk , addrsk ) in ADDR. (If no such key pair is found, abort.)
Compute (c1 , . . . , cn ) ← Receive(pp, (addrpk , addrsk ), L).
Add c1 , . . . , cn to COIN.
Output (cm1 , . . . , cmn ), the corresponding coin commitments.

The ledger L and address set ADDR remain unchanged.
• Q = (Insert, tx)
1. Verify that VerifyTransaction(pp, tx, L) outputs 1. (Else, abort.)
2. Add the mint/pour transaction tx to L.
3. Run Receive for all addresses addrpk in ADDR; this updates the COIN with any coins that
might have been sent to honest parties via tx.
4. Output ⊥.
The address set ADDR remains unchanged.
Remark. The oracle ODAP provides A with two ways to cause a pour transaction to be added to L.
If A has already obtained address public keys addrpk,1 and addrpk,2 (via previous CreateAddress
queries), then A can use a Pour query to elicit a pour transaction txPour (despite not knowing
address secret keys addrsk,1 , addrsk,2 corresponding to addrpk,1 , addrpk,2 ). Alternatively, if A has
himself generated both address public keys, then A knows corresponding address secret keys, and
can invoke Pour “in his head” to obtain a pour transaction txPour , which he can add to L by using
an Insert query. In the first case, both addresses belong to honest users; in the second, both to A.
But what about pour transactions where one address belongs to an honest user and one to A?
Such pour transactions might arise from MPC computations (e.g., to make matching donations).
The ledger oracle ODAP , as defined above, does not support such queries. While extending the
definition is straightforward, for simplicity we leave handling such queries to future work.

C.1

Ledger indistinguishability

Ledger indistinguishability is characterized by an experiment L-IND, which involves a polynomial-size
adversary A attempting to break a given (candidate) DAP scheme.
Definition C.1. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candidate) DAP scheme. We say that Π is L-IND secure if, for every poly(λ)-size adversary A and
sufficiently large λ,
AdvL-IND
Π,A (λ) < negl(λ) ,
41

where AdvL-IND
Π,A (λ) := 2 · Pr[L-IND(Π, A, λ) = 1] − 1 is A’s advantage in the L-IND experiment.
We now describe the L-IND experiment mentioned above. Given a (candidate) DAP scheme Π,
adversary A, and security parameter λ, the (probabilistic) experiment L-IND(Π, A, λ) consists of an
interaction between A and a challenger C, terminating with a binary output by C.
At the beginning of the experiment, C samples b ∈ {0, 1} at random, samples pp ← Setup(1λ ),
and sends pp to A; next, C initializes (using pp) two separate DAP oracles O0DAP and O1DAP (i.e.,
the two oracles have separate ledgers and internal tables).
The experiment proceeds in steps and, at each step, C provides to A two ledgers (LLeft , LRight ),
DAP ; then A sends
where LLeft := Lb is the current ledger in ObDAP and LRight := L1−b the one in O1−b
0
to C a pair of queries (Q, Q ), which must be of the same type (i.e., one of CreateAddress, Mint,
Pour, Receive, Insert). The challenger C acts differently depending on the query type, as follows.
DAP . This allows A to insert his
• If the query type is Insert, C forwards Q to ObDAP , and Q0 to O1−b
own transactions directly in LLeft and LRight .
• For any other query type, C first ensures that Q, Q0 are publicly consistent (see below) and then
forwards Q to O0DAP , and Q0 to O1DAP ; letting (a0 , a1 ) be the two oracle answers, C replies to A
with (ab , a1−b ). This allows A to elicit behavior from honest users. However note that A does not
know the bit b, and hence the mapping between (LLeft , LRight ) and (L0 , L1 ); in other words, A
does not know if he elicits behavior on (L0 , L1 ) or on (L1 , L0 ).
At the end of the experiment, A sends C a guess b0 ∈ {0, 1}. If b = b0 , C outputs 1; else, C outputs 0.
Public consistency. As mentioned above, A sends C pairs of queries (Q, Q0 ), which must be
of the same type and publicly consistent, a property that we now define. If Q, Q0 are both of
type CreateAddress or Receive, then they are always publicly consistent. In the special case of
CreateAddress we require that both oracles generate the same address. If they are both of type
Mint, then the minted value in Q must equal that in Q0 . Finally, if they are both of type Pour,
the following restrictions apply.
First, Q, Q0 must be individually well-formed; namely, (i) the coin commitments referenced by
old
old old
Q (via the two indices idxold
1 , idx2 ) must correspond to coins c1 , c2 that appear in the ledger
old
oracle’s coin table COIN; (ii) the two coins cold
1 , c2 must be unspent (i.e. their serial numbers must
not appear in a valid pour transactions on the corresponding oracle’s ledger); (iii) the address public
old
keys specified in Q must match those in cold
1 , c2 ; and (iv) the balance equation must hold (i.e.,
new
new
old
old
v1 + v2 + vpub = v1 + v2 ).
Furthermore, Q, Q0 must be jointly consistent with respect to public information and A’s view;
namely: (i) the public values in Q and Q0 must equal; (ii) the transaction strings in Q and Q0 must
equal; (iii) for each i ∈ {1, 2}, if the i-th recipient addresses in Q is not in ADDR (i.e., belongs to A)
then vinew in both Q and Q0 must equal (and vice versa for Q0 ); and (iv) for each i ∈ {1, 2}, if the
i-th index in Q references (in L0 ) a coin commitment contained in a transaction that was posted via
an Insert query, then the corresponding index in Q0 must reference (in L1 ) a coin commitment that
also appears in a transaction posted via an Insert query and, moreover, viold in both Q and Q0 must
equal (and vice versa for Q0 ). The challenger C learns viold by looking-up the corresponding coin cold
i
in the oracle’s coin set COIN. (v) for each i ∈ {1, 2} if the i-th index in Q must not reference a coin
that has previously been spent.

C.2

Transaction non-malleability

Transaction non-malleability is characterized by an experiment TR-NM, which involves a polynomialsize adversary A attempting to break a given (candidate) DAP scheme.
42

Definition C.2. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candidate) DAP scheme. We say that Π is TR-NM secure if, for every poly(λ)-size adversary A and
sufficiently large λ,
AdvTR-NM
(λ) < negl(λ) ,
Π,A
where AdvTR-NM
(λ) := Pr[TR-NM(Π, A, λ) = 1] is A’s advantage in the TR-NM experiment.
Π,A
We now describe the TR-NM experiment mentioned above. Given a (candidate) DAP scheme Π,
adversary A, and security parameter λ, the (probabilistic) experiment TR-NM(Π, A, λ) consists of
an interaction between A and a challenger C, terminating with a binary output by C.
At the beginning of the experiment, C samples pp ← Setup(1λ ) and sends pp to A; next, C
initializes a DAP oracle ODAP with pp and allows A to issue queries to ODAP . At the end of the
experiment, A sends C a pour transaction tx∗ , and C outputs 1 if and only if the following conditions
hold. Letting T be the set of pour transactions generated by ODAP in response to Pour queries,
there exists tx ∈ T such that: (i) tx∗ =
6 tx; (ii) VerifyTransaction(pp, tx∗ , L0 ) = 1, where L0 is the
portion of the ledger preceding tx;27 and (iii) a serial number revealed in tx∗ is also revealed in tx.

C.3

Balance

Balance is characterized by an experiment BAL, which involves a polynomial-size adversary A
attempting to break a given (candidate) DAP scheme.
Definition C.3. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candidate) DAP scheme. We say that Π is BAL secure if, for every poly(λ)-size adversary A and
sufficiently large λ,
AdvBAL
Π,A (λ) < negl(λ) ,
where AdvBAL
Π,A (λ) := Pr[BAL(Π, A, λ) = 1] is A’s advantage in the BAL experiment.
We now describe the BAL experiment mentioned above. Given a (candidate) DAP scheme Π,
adversary A, and security parameter λ, the (probabilistic) experiment BAL(Π, A, λ) consists of an
interaction between A and a challenger C, terminating with a binary output by C.
At the beginning of the experiment, C samples pp ← Setup(1λ ), and sends pp to A; next, C
(using pp) initializes a DAP oracle ODAP and allows A to issue queries to ODAP . At the conclusion
of the experiment, A sends C a set of coins Scoin . Recalling that ADDR is the set of addresses
returned by CreateAddress queries (i.e., addresses of “honest” users), C computes the following
five quantities.
• vUnspent , the total value of all spendable coins in Scoin . The challenger C can check if a coin
c ∈ Scoin is spendable as follows: mint a fresh coin c0 of value 0 (via a Mint query) and check if
a corresponding Pour query consuming c, c0 yields a pour transaction txPour that is valid.
• vMint , the total value of all coins minted by A. To compute vMint , the challenger C sums up
the values of all coins that (i) were minted via Mint queries using addresses not in ADDR, or
(ii) whose mint transactions were directly placed on the ledger via Insert queries.
• vADDR→A , the total value payments received by A from addresses in ADDR. To compute vADDR→A ,
the challenger C looks up all pour transactions placed on the ledger via Pour queries and sums
up the values that were transferred to addresses not in ADDR.
27

That is, L0 is the longest ledger prefix that can be used to spend at least one of the coins spent in tx.

43

• vA→ADDR , the total value of payments sent by A to addresses in ADDR. To compute vA→ADDR ,
the challenger C first deduces the set S 0 ⊆ COIN of all coins received by honest parties and then
sums up the values of coins in S 0 . (Note that C can compute S 0 by selecting all coins in COIN
that are both tied to an address in ADDR and arose from transactions placed on the ledger by
Insert queries.)
• vBasecoin , the total value of public outputs placed by A on the ledger. To compute vBasecoin , the
challenger C looks up all pour transactions placed on the ledger by Insert and sums up the
corresponding vpub values.
At the end of the experiment, C outputs 1 if vUnspent + vBasecoin + vA→ADDR > vMint + vADDR→A ; else,
C outputs 0.
Remark. There are two methods for A to spend more public-output money than he owns: (i) by
directly inserting transactions on the ledger, and (ii) by asking honest parties to create such
transactions. The first method is accounted for in the computation of vBasecoin , while the second
method is accounted for in the computation of vA→ADDR (since A must first pay the honest party).

D

Proof of Theorem 4.1

We prove Theorem 4.1. We omit a formal proof of the completeness claim; one can verify that
the DAP scheme’s completeness follows, in a straightforward way, from the completeness of the
construction’s building blocks. Next, we argue security via three separate proofs, respectively showing
that our construction satisfies (i) ledger indistinguishability, (ii) transaction non-malleability, and
(iii) balance.

D.1

Proof of ledger indistinguishability

We describe a simulation asim in which the adversary A interacts with a challenger C, as in the
L-IND experiment. However asim differs from the L-IND experiment in a critical way: all answers
sent to A are computed independently of the bit b, so that A’s advantage in asim is 0. The remainder
of the proof is devoted to showing that AdvL-IND
Π,A (λ) (i.e., A’s advantage in the L-IND experiment) is
at most negligibly different than A’s advantage in asim .
The simulation. The simulation asim works as follows. First, after sampling b ∈ {0, 1} at random,
C samples pp ← Setup(1λ ), with the following modification: the zk-SNARK keys are generated as
(pkPOUR , vkPOUR , trap) ← Sim(1λ , CPOUR ), to obtain the zero-knowledge trapdoor trap. Then, as in the
L-IND experiment, C sends pp to A, and then initializes two separate DAP oracles O0DAP and O1DAP .
Afterwards, as in L-IND, asim proceeds in steps and, at each step, C provides to A two ledgers
DAP ;
(LLeft , LRight ), where LLeft := Lb is the current ledger in ObDAP and LRight := L1−b the one in O1−b
then A sends to C a message (Q, Q0 ), which consist of two (publicly-consistent) queries of the same
type. The challenger C acts differently depending on the query type, as follows.
• Answering CreateAddress queries. In this case, Q = Q0 = CreateAddress.
To answer Q, C behaves as in L-IND, except for the following modification: after obtaining
(addrpk , addrsk ) ← CreateAddress(pp), C replaces apk in addrpk with a random string of the appropriate length; then, C stores addrsk in a table and returns addrpk to A.
Afterwards, C does the same for Q0 .

44

• Answering Mint queries. In this case, Q = (Mint, v, addrpk ) and Q0 = (Mint, v, addr0pk ).
To answer Q, C behaves as in L-IND, except for the following modification: the Mint algorithm
computes the commitment k as COMMr (τ kρ), for a random string τ of the appropriate length,
instead of as COMMr (apk kρ), where apk is the value specified in addrpk .
Afterwards, C does the same for Q0 .
old
old
• Answering Pour queries. In this case, Q and Q0 both have the form (Pour, cmold
1 , cm2 , addrpk,1 ,
old
new
new
new ).
addrpk,2 , info, v1new , v2new , addrpk,1 , addrpk,2 , vpub

To answer Q, C modifies the way some values are computed:
1. Compute rti by accumulating all of the valid coin commitments on Li .
2. Set vpub and info to the corresponding input values.
3. For each j ∈ {1, 2}:
(a) Sample a uniformly random snold
j .
is
an
address
generated
by a previous query to CreateAddress, (i) sample
(b) If addrnew
pk,j
a coin commitment cmnew
on
a
random
input, (ii) run Kenc (ppenc ) → (pkenc , skenc ) and
j
new
compute Cj := Eenc (pkenc , r) for a random r of suitable length.
new
28
(c) Otherwise, calculate (cmnew
i , Ci ) as in the Pour algorithm.
4. Set h1 and h2 to be random strings of the appropriate length.
5. Compute all remaining values as in the Pour algorithm
old
new
new
6. The pour proof is computed as πPOUR := Sim(trap, x), where x := (rt, snold
1 , sn2 , cm1 , cm2 , vpub , h1 , h2 ).
Afterwards, C does the same for Q0 .
• Answering Receive queries. In this case, Q = (Receive, addrpk ) and Q0 = (Receive, addr0pk ).
The answer to each query proceeds as in the L-IND experiment.
• Answering Insert queries. In this case, Q = (Insert, tx) and Q = (Insert, tx0 ). The answer to
each query proceeds as in the L-IND experiment.
In each of the above cases, the response to A is computed independently of the bit b. Thus, when
A outputs a guess b0 , it must be the case that Pr [ b = b0 ] = 1/2, i.e., A’s advantage in asim is 0.
Proof that the simulation is indistinguishable from the real experiment. We now describe
a sequence of hybrid experiments (areal , a1 , a2 , a3 , asim ) in each of which a challenger C conducts a
modification of the L-IND experiment with A. We define areal to be the original L-IND experiment,
and asim to be the simulation described above.
With a slight abuse of notation, given experiment a, we define Adva to be the absolute value of the
difference between (i) the L-IND advantage of A in a and (ii) the L-IND advantage of A in areal .
Also, let
• qCA be the total number of CreateAddress queries issued by A,
• qP be the total number of Pour queries issued by A, and
• qM be the total number of Mint queries issued by A.
Finally, define AdvEnc to be A’s advantage in Enc’s IND-CCA and IK-CCA experiments, AdvPRF to be
A’s advantage in distinguishing the pseudorandom function PRF from a random one, and AdvCOMM
to be A’s advantage against the hiding property of COMM.
We now describe each of the hybrid experiments.
28

Note that by the restrictions of the experiment, the value vinew is identical between QLeft and QRight .

45

• Experiment a1 . The experiment a1 modifies areal by simulating the zk-SNARKs. More
precisely, we modify areal so that C simulates each zk-SNARK proof, as follows. At the beginning
of the experiment, instead of invoking KeyGen(1λ , CPOUR ), C invokes Sim(1λ , CPOUR ) and obtains
(pkPOUR , vkPOUR , trap). At each subsequent invocation of the Pour algorithm, C computes πPOUR ←
Sim(trap, x), without using any witnesses, instead of using Prove. Since the zk-SNARK system is
perfect zero knowledge, the distribution of the simulated πPOUR is identical to that of the proofs
computed in areal . Hence Adva1 = 0.
• Experiment a2 . The experiment a2 modifies a1 by replacing the ciphertexts in a pour
transaction by encryptions of random strings. More precisely, we modify a1 so that, each time A
new
issues a Pour query where one of the output addresses (addrnew
pk,1 , addrpk,2 ) is in the set of addresses
new are generated
previously generated by a CreateAddress query, the two ciphertexts Cnew
1 , C2
new
new
new
as follows: (i) (pkenc , skenc ) ← Kenc (ppenc ); (ii) for each j ∈ {1, 2}, Cj := Eenc (pknew
enc,j , r) where r
is a message sampled uniformly from the plaintext space of the encryption scheme. By Lemma D.1
(see below), |Adva2 − Adva1 | ≤ 4 · qP · AdvEnc .
• Experiment a3 . The experiment a3 modifies a2 by replacing all PRF-generated values with
random strings. More precisely, we modify a2 so that:
– each time A issues a CreateAddress query, the value apk within the returned addrpk is
substituted with a random string of the same length;
old
– each time A issues a Pour query, each of the serial numbers snold
1 , sn2 in txPour is substituted
with a random string of the same length, and hinfo with a random string of the same length.
By Lemma D.2 (see below), |Adva3 − Adva2 | ≤ qCA · AdvPRF .
• Experiment asim . The experiment asim is already described above. For comparison, we explain
how it differs from a3 : the coin commitments are replaced with commitments to random inputs.
More precisely, we modify a3 so that:
– each time A issues a Mint query, the coin commitment cm in txMint is substituted with a
commitment to a random input; and
– each time A issues a Pour query, then, for each j ∈ {1, 2}, if the output address addrnew
pk,j is in
the set of addresses previously generated by an CreateAddress query, cmnew
is
substituted
j
with a commitment to a random input.
By Lemma D.3 (see below), |Advasim − Adva3 | ≤ (qM + 4 · qP ) · AdvCOMM .
As argued above, the responses provided to A in asim are independent of the bit b, so that Advasim = 0.
Then, by summing over A’s advantages in the hybrid experiments, we can bound A’s advantage in
areal by
Enc
AdvL-IND
+ qCA · AdvPRF + (qM + 4 · qP ) · AdvCOMM ,
Π,A (λ) ≤ 4 · qP · Adv
which is negligible in λ. This concludes the proof of ledger indistinguishability. Below, we sketch
proofs for the lemmas used above (Lemma D.1, Lemma D.2, and Lemma D.3).
Lemma D.1. Let AdvEnc be the maximum of:
• A’s advantage in the IND-CCA experiment against the encryption scheme Enc, and
• A’s advantage in the IK-CCA experiment against the encryption scheme Enc.
Then after qP Pour queries, |Adva2 − Adva1 | ≤ 4 · qP · AdvEnc .

46

Proof sketch. Define  := Adva2 − Adva1 . Using A, we first show how to construct a solver with
advantage ≥ 2·q P in the IK-CCA or IND-CCA experiments. We use a hybrid H, intermediate between
a1 and a2 ; concretely, H modifies a1 so that each ciphertext (where the corresponding public key
appears in the set generated by a CreateAddress query) is replaced with the encryption of the same
plaintext, but under a new, random public key generated via the Kenc algorithm. (For comparison,
a2 modifies H so that each plaintext is replaced with a random plaintext drawn from the plaintext
space.) We now argue that A’s advantage in distinguishing H and a1 is at most 2 · qP · AdvEnc , and
so is for distinguishing a2 and H. Overall, we deduce that |Adva2 − Adva1 | ≤ 4 · qP · AdvEnc .
First, we discuss H and a1 . For some j ∈ {1, . . . , qCA }, when A makes the j-th query of the
form CreateAddress, query the IK-CCA challenger to obtain two public keys (pkenc,0 , pkenc,1 ) and
return pkenc := pkenc,0 in the response to A. At the time A issues a Pour query that results in the
i-th ciphertext Ci being encrypted under pkenc , query the IK-CCA challenger on the corresponding
plaintext m and receive C∗ = Eenc (pkenc,b̄ , m) where b̄ is the bit chosen by the IK-CCA challenger.
Substitute Ci := C∗ and write the resulting txPour to the Ledger. When A outputs b0 we return
this guess as our guess in the IK-CCA experiment. We note that when b̄ = 0 then A’s view of the
interaction is distributed identically to that of a1 , and when b̄ is 1 then A’s view represents an
intermediate hybrid where one key has been substituted. By a standard hybrid argument over each
of the 2 · qP ciphertexts, we note that over the random coins of the experiment, our solver must
succeed in the IK-CCA experiment with advantage ≥ 2·q P . If we assume a maximum adversarial
advantage AdvEnc against the IK-CCA experiment for the encryption scheme, then we get that
AdvH − Adva2 ≤ 2 · qP · AdvEnc .
Next, we discuss a2 and H; the argument is similar to the above one. This time, rather than
replacing the key used to encrypt, we replace the plaintext with a random message drawn from
the plaintext space; this final distribution is the same as in a2 . We omit the formal description of
the resulting IND-CCA solver (which essentially follows the pattern above), and simply note that
Adva2 − AdvH ≤ 2 · qP · AdvEnc .
Lemma D.2. Let AdvPRF be A’s advantage in distinguishing the pseudorandom function PRF from
a random function. Then, after qCA CreateAddress queries, |Adva3 − Adva2 | ≤ qCA · AdvPRF .
Proof sketch. We first describe a hybrid H, intermediate between a2 and a3 , in which all values
computed using the first (rather than all) oracle-generated key ask are replaced with random strings.
Then, we show that A’s advantage in distinguishing between H and a2 is at most AdvPRF . Finally,
we extend the argument to all qCA oracle-generated keys (corresponding to what happens in a3 ).
We now describe H. On receiving A’s first CreateAddress query, replace the public address
addrpk = (apk , pkenc ) with addrpk = (τ, pkenc ) where τ is a random string of the appropriate length.
On each subsequent Pour query, for each i ∈ {1, 2}, if addrold
pk,i = addrpk then:
old
1. in the output txPour , replace sni with a random string of appropriate length;
2. in the output txPour , replace each of h1 , h2 with a random string of appropriate length.
3. simulate the zk-SNARK proof πPOUR for the new transaction.
Note that the above modifications do not affect the computation of the zk-SNARK proof πPOUR ,
because πPOUR is simulated with the help of a trapdoor.
We now argue that A’s advantage in distinguishing between H and a2 is at most AdvPRF . Let ask
be the random, secret seed for PRF generated by the oracle in answering the first CreateAddress
query. In a2 (as in areal ):
• apk := PRFaddr
ask (0);
• for each i ∈ {1, 2}, sni := PRFsn
ask (ρ) for a random (and not previously used) ρ
47

• for each i ∈ {1, 2}, hi := PRFpk
ask (ikhSig ) and, with overwhelming probability, hSig is unique.
addr
sn
Moreover, each of PRFask , PRFask , PRFpk
ask are constructed from PRFask as specified in Section 4.1.
Note that, with overwhelming probability, no two calls to PRFask are made on the same input. First,
sn
pk
even identical inputs passed to PRFaddr
ask , PRFask , PRFask produce different underlying calls to PRFask .
sn
Second, within each construction, there is exactly one call to PRFaddr
ask , and the calls to PRFask are
each by definition unique. Finally, with overwhelming probability, the calls to PRFpk
ask from different
transactions each reference a distinct digest hSig , and, within a given transaction, the two calls each
begin with a distinct prefix.
Now let O be an oracle that implements either PRFask or a random function. We show that if
A distinguishes H from a2 with probability , then we can construct a distinguisher for the two
sn
pk
cases of O. In either case we use O to generate all values computed using PRFaddr
ask , PRFask , PRFask .
Clearly, when O implements PRFask , the distribution of the experiment is identical to a2 ; instead,
when O implements a random function, the distribution of the experiment is identical to H. Thus,
A’s advantage is at most AdvPRF .
Finally, by a standard hybrid argument, we extend the above to all qCA oracle-generated
addresses; then, A’s differential distinguishing advantage is at most qCA · AdvPRF . Because this final
hybrid is equal to a3 , we deduce that |Adva3 − Adva2 | ≤ qCA · AdvPRF .
Lemma D.3. Let AdvCOMM be A’s advantage against the hiding property of COMM. After qM
Mint queries and qP Pour queries, |Advasim − Adva3 | ≤ (qM + 4 · qP ) · AdvCOMM .
Proof sketch. We only provide a short sketch, because the structure of the argument is similar to
the one used to prove Lemma D.2 above.
For the first Mint or Pour query, replace the “internal” commitment k := COMMr (apk kρ) with
a random string of the appropriate length. Since ρ is random (and unique), then A’s advantage
in distinguishing this modified experiment from a2 is at most AdvCOMM . Then, if we similarly
modify all qM Mint queries and all qP Pour queries, by replacing the resulting qM + 2 · qP internal
commitments with random strings, we can bound A’s advantage by (qM + 2 · qP ) · AdvCOMM .
Next, in a similar vein, if replace the coin commitment in the first Pour with a commitment to
a random value, then A’s advantage in distinguishing this modified experiment from the above one
is at most AdvCOMM . Then, if we similarly modify all qP Pour queries, by replacing the resulting
2 · qP coin commitments with random strings, we obtain the experiment asim , and deduce that
|Advasim − Adva3 | ≤ (qM + 4 · qP ) · AdvCOMM .

D.2

Proof of transaction non-malleability

Letting T be the set of pour transactions generated by ODAP in response to Pour queries, recall
that A wins the TR-NM experiment whenever it outputs tx∗ such that there exists tx0 ∈ T such that:
(i) tx∗ =
6 tx0 ; (ii) VerifyTransaction(pp, tx∗ , L0 ) = 1, where L0 is the portion of the ledger preceding
0
tx ; and (iii) a serial number revealed in tx∗ is also revealed in tx0 . Being a pour transaction, tx∗
old
new
new
has the form (rt, snold
1 , sn2 , cm1 , cm2 , vpub , info, ∗), where ∗ := (pksig , h1 , h2 , πPOUR , C1 , C2 , σ); set
hSig := CRH(pksig ). Let pk0sig be the corresponding public key in tx0 and set h0Sig := CRH(pk0sig ).
Define  := AdvTR-NM
(λ), and let QCA = {ask,1 , . . . , ask,qCA } be the set of internal address keys
Π,A
created by C in response to A’s CreateAddress queries. Let QP = (pksig,1 , . . . , pksig,qP ) be the set
of signature public keys created by C in response to A’s Pour queries. We decompose the event in
which A wins into the following four disjoint events.
• Eventsig : A wins, and there is pk00sig ∈ QP such that pksig = pk00sig .
48

• Eventcol : A wins, the above event does not occur, and there is pk00sig ∈ QP such that hSig =
CRH(pk00sig ).
• Eventmac : A wins, the above two events do not occur, and hi = PRFpk
a (ikhSig ) for some i ∈ {1, 2}
and a ∈ QCA .
• Eventkey : A wins, the above three events do not occur, and hi 6= PRFpk
a (ikhSig ) for all i ∈ {1, 2}
and a ∈ QCA .
Clearly,  = Pr [ Eventsig ] + Pr [ Eventcol ] + Pr [ Eventkey ] + Pr [ Eventmac ]. Hence, to show
that  is negligible in λ, it suffices to argue that each of these probabilities is negligible in λ.
Bounding the probability of Eventsig . Define 1 := Pr [ Eventsig ]. Let σ be the signature
in tx∗ , and σ 00 be the signature in the first pour transaction tx00 ∈ T that contains pk00sig . When
Eventsig occurs, since pksig = pk00sig , the two signatures are with respect to the same public key.
Moreover, since tx∗ is valid, Vsig (pksig , m, σ) = 1 where m is everything in tx∗ but for σ. Let m00
consist of all elements in tx00 but for σ 00 . Observe that whenever tx∗ 6= tx00 we also have (m, σ)
6= (m00 , σ 00 ). We use this fact below to show that A forges a signature with non-negligible probability.
First, we argue that, conditioned on Eventsig , tx∗ 6= tx00 with overwhelming probability; we do
so by way of contradiction. First, since A wins, by definition there is tx0 ∈ T such that tx∗ =
6 tx0
and yet each of tx∗ and tx0 share one serial number. Therefore: (i) tx∗ 6= tx0 ; and (ii) if tx∗ = tx00
then tx00 and tx0 also share a serial number. However the probability that tx0 and tx00 share a serial
number is bounded by the probability p̃ that T contains two transactions that share the same serial
number. Because each serial number is computed as PRFsn
ask (ρ), where ρ is random, p̃ is negligible.
We conclude that tx∗ 6= tx00 with all but negligible probability.
Next, we describe an algorithm B, which uses A as a subroutine, that wins the SUF-1CMA game
against Sig with probability 1 /qP . After receiving a verification key pk00sig from the SUF-1CMA
challenger, the algorithm B performs the following steps.
1. B selects a random index j ← {1, . . . , qP }.
2. B conducts the TR-NM experiment with A, except that, when A issues the j-th Pour query,
B executes Pour as usual, but modifies the resulting pour transaction tx00 as follows: (i) it
substitutes pk00sig for the signature public key in tx00 ; (ii) it queries the SUF-1CMA challenger to
obtain σ 00 on the appropriate message m00 ; and (iii) it substitutes σ 00 for the signature in tx00 .
3. When A outputs tx∗ , B looks into tx∗ to obtain pksig , m, and σ.
4. If pksig 6= pk00sig then B aborts; otherwise B outputs (m, σ) as a forgery for Sig.
Note that tx00 has the same distribution has an “untampered” pour transaction; thus, all transactions
returned to A are distributed as in the TR-NM experiment. Since the index j is selected at random,
B succeeds in the experiment with probability at least 1 /qP . Because Sig is SUF-1CMA, 1 must
be negligible in λ.
Bounding the probability of Eventcol . Define 2 := Pr [ Eventcol ]. When Eventcol occurs,
A receives a transaction tx0 containing a public key pk00sig , and subsequently outputs a transaction
tx∗ containing a public key pksig such that (i) pksig 6= pk00sig , but (ii) CRH(pksig ) = CRH(pk0sig ). In
particular, A finds collisions for CRH with probability 2 . Because CRH is collision resistant, 2
must be negligible in λ.
Bounding the probability of Eventmac . Define 3 := Pr [ Eventmac ]. We first define an experiment a1 , which modifies the TR-NM experiment as follows. When C samples pp ← Setup(1λ ), the
sub-call to (pkPOUR , vkPOUR ) ← KeyGen(1λ , CPOUR ) is replaced by (pkPOUR , vkPOUR , trap) ← Sim(1λ , CPOUR ),
so to obtain the zero-knowledge trapdoor trap. Afterwards, each time A issues a Pour query, C
replaces the zk-SNARK proof in the resulting pour transaction with a simulated proof, obtained by
running Sim(trap, x) for an appropriate input x. Because the zk-SNARK is perfect zero knowledge,
Pr [ Eventmac ] = 3 in the a1 experiment as well.
49

Assume by way of contradiction that 3 is non-negligible. We now show how to construct an
attacker B, which uses A as a subroutine, that distinguishes PRF from a random function RAND
with non-negligible probability. The algorithm B, which has access either to O = PRF or O = RAND,
“interfaces” between A and C in the experiment a1 above, as follows.
1. First, B selects a random index j ← {1, . . . , qCA }, which identifies ask,j ∈ QCA .
2. Next, B uses the oracle O instead of PRFask,j , i.e., anytime a value needs to be computed
depending on PRFask,j (z), for some z, O(z) is used instead. (For instance, the public address
key apk,j is one such value.)
3. Finally, after A outputs tx∗ :
(a) if O has been previously evaluated the expression “PRFpk
ask,j (ikhSig )” using O, B aborts
and outputs 1;
(b) otherwise, B evaluates the expression “PRFpk
ask,j (ikhSig )” by using O; if the result equals
hi , B outputs 1, else it outputs 0.
Conducting the above strategy does not require knowledge of ask,j because, having the simulation
trapdoor, B does not need witnesses to generate

(valid) zk-SNARK
 proofs.
We now argue that Pr B PRF (1λ ) = 1 − Pr B RAND (1λ ) = 1 is non-negligible.
• Case 1: O = RAND. Observe that:
h
i
Pr B RAND (1λ ) = 1 | B RAND (1λ ) does not abort = 2−ω .
where ω is the output length of PRF. Hence:
h
i 
h
i
h
i
Pr B RAND (1λ ) = 1 = 1 − Pr B RAND (1λ ) aborts · 2−ω + Pr B RAND (1λ ) aborts .
• Case 2: O = PRF. In this case the distribution of the simulation is identical to that of a1 , and B
has set ask,j equal to the seed used by O. Recall that, when Eventmac holds, hi = PRFpk
a (ikhSig )
for some a ∈ QCA . Since A’s view of the experiment is independent of j, the probability that
a = ask,j is at least 1/qCA , and the probability that hi = PRFpk
ask,j (ikhSig ) is at least 3 /qCA .
Hence:
h
i
Pr B PRF (1λ ) = 1 | B PRF (1λ ) does not abort = 3 /qCA .
Thus:
h
i 
h
i
h
i
Pr B PRF (1λ ) = 1 = 1 − Pr B PRF (1λ ) aborts · 3 /qCA + Pr B PRF (1λ ) aborts .
Clearly, 2−ω is negligible;
then so is |3 /qCA |. Thus, to show
 moreover,
 RAND if λ3 is non-negligible,

PRF
λ
that
(1 ) = 1 − Pr B
(1 ) = 1 is non-negligible, it suffices to show that each of
 Pr B
Pr B RAND (1λ ) aborts and Pr B PRF (1λ ) aborts is negligible.
To do so, recall that B aborts if and only if it has previously evaluated the expression
“PRFpk
ask,j (ikhSig )” using O prior to receiving A’s output. First note that B’s only calls to O occur
when it evaluates the functions PRFaddr , PRFsn and PRFpk . Moreover, due to the construction
of these functions it is not possible to evaluate the expression PRFpk
ask,j (ikhSig ) using any calls to
addr
sn
PRF
or PRF . Thus B aborts if and only if it has previously queried PRFpk on the expression
PRFpk
ask,j (ikhSig ). However it is easy to see that this cannot happen under the conditions of Eventmac ,
since such a query would imply the condition Eventsig or Eventcol , each of which is excluded by
Eventmac . Hence the probability of either condition occurring is 0.
50

Bounding the probability of Eventkey . Define 4 := Pr [ Eventkey ], and let E be the zk-SNARK
extractor for A. Assume by way of contradiction that 4 is non-negligible. We construct an algorithm
B that finds collisions for PRFsn with non-negligible probability (contradicting the fact that PRFsn
is collision resistant). The algorithm B works as follows.
1. Run A (simulating its interaction with the challenger C) to obtain tx∗ .
2. Run E(pkPOUR , vkPOUR ) to obtain a witness a for the zk-SNARK proof πPOUR in tx∗ .
old
new
new
3. If a is not a valid witness for the instance x := (rt, snold
1 , sn2 , cm1 , cm2 , vpub , hSig , h1 , h2 ),
abort and output 0.
old
old
old
new new
4. Parse a as (path1 , path2 , cold
1 , c2 , addrsk,1 , addrsk,2 , c1 , c2 ).
old
old old old old
old
5. For each i ∈ {1, 2}, parse cold
i as (addrpk,i , vi , ρi , ri , si , cmi ).
old
old
6. For each i ∈ {1, 2}, parse addrold
sk,i as (ask,i , skenc,i ).
sn
old
(Note that, since a is a valid witness, snold
i = PRFaold (ρi ) for all i ∈ {1, 2}.)
sk,i

7. For each i ∈ {1, 2}:
(a) Look for a pour transaction tx ∈ T that contains snold
i .
(b) If one tx is found, let ask and ρ be the seed and input usedto compute snold
i in tx; thus,
sn
old 6= a , output (aold , ρold ), (a , ρ) as a collision for PRFsn .
snold
=
PRF
(ρ).
If
a
sk
sk
ask
i
sk,i
sk,i i
Note that, whenever Eventkey holds:
• the proof πPOUR is valid and, with all but negligible probability, the witness a is valid;
old
• the serial number snold
1 or sn2 appears in some previous pour transaction in T ;
• whenever a is valid, it holds that h1 = PRFpk
(hSig ) and h2 = PRFpk
(hSig ), so that it cannot
aold
aold
sk,1

sk,2

old
be that aold
sk,1 = ask,2 = ask (as this contradicts the conditions of the event Eventkey ).
Overall, we conclude that B finds a collision for PRFsn with probability 4 − negl(λ).

D.3

Proof of balance

Define  := AdvBAL
Π,A (λ); our goal is to show that  is negligible in λ. Recall that ADDR is the set of
addresses returned by A’s CreateAddress queries.
Augmenting the ledger with witnesses. We modify the BAL experiment in a way that does
not affect A’s view: the challenger C computes, for each pour transaction txPour on the ledger L
old
old
old
new new
(maintained by the oracle ODAP ), a witness a = (path1 , path2 , cold
1 , c2 , addrsk,1 , addrsk,2 , c1 , c2 )
old
new
new
for the zk-SNARK instance x = (rt, snold
1 , sn2 , cm1 , cm2 , vpub , hSig , h1 , h2 ) corresponding to
29
txPour . In this way, C obtains an augmented ledger (L, ~a), where ai is a witness for the zk-SNARK
instance xi of the i-th pour transaction in L. Note that we can parse (L, ~a) as a list of matched
pairs (txPour , a) where txPour is a pour transaction in L and a is its corresponding witness.
The discussion below is relative to the above modification of the BAL experiment.
Balanced ledgers. We say that an augmented ledger (L, ~a) is balanced if the following holds.
I. Each (txPour , a) in (L, ~a) contains openings (i.e., decommitments) of two distinct coin comold
old
mitments cmold
1 and cm2 ; also, each cmi is the output coin commitment of a pour or mint
transaction that precedes txPour on L.
II. No two (txPour , a) and (a0 , tx0Pour ) in (L, ~a) contain openings of the same coin commitment.
29

Concretely, for pour transactions in L not inserted by A, C simply retains the witness a internally used by ODAP
to generate the transaction. As for the (valid) pour transactions inserted by A, C uses the zk-SNARK multi-instance
knowledge extractor corresponding to A; see Section 2.1. (If knowledge extraction fails, C aborts and outputs 1.
However, this only happens with negligible probability.)

51

old
new
new to values v old , v old ,
III. Each (txPour , a) in (L, ~a) contains openings of cmold
1 , cm2 , cm1 , cm2
1
2
v1new , v2new (respectively), with the condition that v1old + v2old = v1new + v2new + vpub .

IV. For each (txPour , a) in (L, ~a) and for each i ∈ {1, 2}, the following conditions hold:
(a) If cmold
i is also the output of a mint transaction txMint on L, then the public value v in
txMint is equal to viold .
0
0
(b) If cmold
i is also the output of a pour transaction txPour on L, then its witness a contains
old
0
old
an opening of cmi to a value v that is equal to vi .
V. For each (txPour , a) in (L, ~a), where txPour was inserted by A, it holds that, for each i ∈ {1, 2},
0
if cmold
i is the output of an earlier mint or pour transaction tx , then the public address of the
0
i-th output of tx is not contained in ADDR.
Intuitively, the above conditions ensure that, in L, A did not spend money that was not previously
minted, or paid to an address under A’s control. Concretely, one can prove by induction that if
(L, ~a) is balanced then vUnspent + vBasecoin + vA→ADDR > vMint + vADDR→A .
In light of the above, it suffices to argue that the augmented ledger induced by the (modified) BAL
experiment is balanced with all but negligible probability. Suppose, by way of contradiction, that is
is not the case: A induces, with non-negligible probability, an augmented ledger (L, ~a) that is not
balanced. We distinguish between five cases, corresponding to which one of the above conditions
does not hold with non-negligible probability. In each case, we show how to reach a contradiction,
concluding the proof.
A violates Condition I. Suppose that Pr [ A wins but violates Condition I ] is non-negligible.
By construction of ODAP , every (txPour , a) in (L, ~a) for which txPour was not inserted by A satisfies
Condition I; thus, the violation can only originate from a pair (txPour , a) in (L, ~a) for which txPour
old
old
was inserted by A and such that: (i) cmold
1 = cm2 ; or (ii) there is i ∈ {1, 2} such that cmi has no
corresponding output coin commitment in any pour or mint transaction that precedes txPour on L.
Observe that the validity of txPour implies that:
old
old equals
• The two serial numbers snold
1 and sn2 are distinct. Moreover, recalling that each sni
sn
old
old
old
old
old
PRFaold (ρi ), this also implies that (ask,1 , ρ1 ) 6= (ask,2 , ρ2 ).
sk,i

• The witness a contains two valid authentication paths path1 , path2 for a Merkle tree constructed
using only coin commitments of transactions preceding txPour in L.
In either (i) or (ii), we reach a contradiction. Indeed:
old
old
old
(i) If cmold
1 = cm2 , then the fact that sn1 6= sn2 implies that the witness a contains two
old
old
distinct openings of cm1 (the first opening contains (aold
sk,1 , ρ1 ), while the second opening
old
contains (aold
sk,2 , ρ2 )). This violates the binding property of the commitment scheme COMM.
(ii) If there is i ∈ {1, 2} such that cmold
i does not previously appear in L, then pathi is an invalid
authentication path, and thus yields a collision in the function CRH. This violates the collision
resistance of CRH.
A violates Condition II. Suppose that Pr [ A wins but violates Condition II ] is non-negligible.
Observe that, when Condition II is violated, L contains two pour transactions txPour , tx0Pour spending
the same coin commitment cm, and revealing two serial numbers sn and sn0 . Since txPour , tx0Pour are
valid, it must be the case that sn =
6 sn0 . However (as argued already above), if both transactions
spend cm but produce different serial numbers, then the corresponding witnesses a, a0 contain
different openings of cm. This contradicts the binding property of the commitment scheme COMM.
A violates Condition III. Suppose that Pr [ A wins but violates Condition III ] is non-negligible.
In this case, the contradiction is immediate: whenever Condition III is violated, the equation
52

v1old + v2old = v1new + v2new + vpub does not hold, and thus, by construction of the statement POUR, the
soundness of the zk-SNARK is violated as well.
A violates Condition IV. Suppose that Pr [ A wins but violates Condition IV ] is non-negligible.
Observe that, when Condition IV is violated, L contains:
• a pour transaction txPour in which a coin commitment cmold is opened to a value v old ; and also
• a (mint or pour) transaction tx0 that opens cmold to a value v 0 different from v old .
This contradicts the binding property of the commitment scheme COMM.
A violates Condition V. Suppose that Pr [ A wins but violates Condition V ] is non-negligible.
Observe that, when Condition V is violated, L contains an inserted pour transaction txPour that
spends the output of a previous transaction tx0 whose public address addrpk = (apk , pkenc ) lies in
ADDR; moreover, the witness associated to tx0 contains ask such that apk = PRFaddr
ask (0). We omit
the full argument, but one can verify that, in this case, we can construct a new adversary B that
uses A to distinguish, with non-negligible probability, PRF from a random function.

53

References
[BB04]

Dan Boneh and Xavier Boyen. Secure identity based encryption without random oracles. In Proceedings
of the 24th Annual International Cryptology Conference, CRYPTO ’04, pages 443–459, 2004.

[BBDP01]

Mihir Bellare, Alexandra Boldyreva, Anand Desai, and David Pointcheval. Key-privacy in publickey encryption. In Proceedings of the 7th International Conference on the Theory and Application of
Cryptology and Information Security, ASIACRYPT ’01, pages 566–582, 2001.

[BBSU12]

Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to better - how to make Bitcoin a
better currency. In Proceedings of the 16th International Conference on Financial Cryptography and Data
Security, FC ’12, pages 399–414, 2012.

[BCCT12]

Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to
succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations
in Theoretical Computer Science Conference, ITCS ’12, pages 326–349, 2012.

[BCCT13]

Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping
for SNARKs and proof-carrying data. In Proceedings of the 45th ACM Symposium on the Theory of
Computing, STOC ’13, pages 111–120, 2013.

[BCG+ 13]

Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for
C: verifying program executions succinctly and in zero knowledge. In Proceedings of the 33rd Annual
International Cryptology Conference, CRYPTO ’13, pages 90–108, 2013.

[BCGT13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to
delegatable succinct constraint satisfaction problems. In Proceedings of the 4th Innovations in Theoretical
Computer Science Conference, ITCS ’13, pages 401–414, 2013.
[BCGT13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. On the concrete efficiency
of probabilistically-checkable proofs. In Proceedings of the 45th ACM Symposium on the Theory of
Computing, STOC ’13, pages 585–594, 2013.
[BCI+ 13]

Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct noninteractive arguments via linear interactive proofs. In Proceedings of the 10th Theory of Cryptography
Conference, TCC ’13, pages 315–333, 2013.

[BCTV14]

Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero
knowledge for a von Neumann architecture. In Proceedings of the 23rd USENIX Security Symposium,
Security ’14, pages ???–???, 2014. Available at http://eprint.iacr.org/2013/879.

[Bel06]

Mihir Bellare. New proofs for NMAC and HMAC: security without collision-resistance. In Proceedings of
the 26th Annual International Conference on Advances in Cryptology, CRYPTO ’06, pages 602–619, 2006.

[Ben13]

Eli Ben-Sasson. Universal and affordable computational integrity, May 2013. Bitcoin 2013: The Future
of Payments. URL: http://www.youtube.com/watch?v=YRcPReUpkcU&feature=youtu.be&t=26m6s.

[BFLS91]

László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, STOC ’91,
pages 21–32, 1991.

[BGH+ 05]

Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil Vadhan. Short PCPs
verifiable in polylogarithmic time. In Proceedings of the 20th Annual IEEE Conference on Computational
Complexity, CCC ’05, pages 120–134, 2005.

[Cer00]

Certicom Research. SEC 1: Elliptic curve cryptography, 2000. URL: http://www.secg.org/collateral/
sec1_final.pdf.

[Cha82]

David Chaum. Blind signatures for untraceable payments. In Proceedings of the 2nd Annual International
Cryptology Conference, CRYPTO ’82, pages 199–203, 1982.

[CHL05]

Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Proceedings of the 24th
Annual International Conference on Theory and Applications of Cryptographic Techniques, EUROCRYPT
’05, pages 302–321, 2005.

[CL01]

Jan Camenisch and Anna Lysyanskaya. An efficient system for non-transferable anonymous credentials
with optional anonymity revocation. In Proceedings of the 20th Annual International Conference on
Theory and Application of Cryptographic Techniques, EUROCRYPT ’01, pages 93–118, 2001.

[DDM03]

George Danezis, Roger Dingledine, and Nick Mathewson. Mixminion: Design of a type III anonymous
remailer protocol. In Proceedings of the 2003 IEEE Symposium on Security and Privacy, SP ’03, pages
2–15, 2003.

54

[DFKP13]

George Danezis, Cedric Fournet, Markulf Kohlweiss, and Bryan Parno. Pinocchio Coin: building Zerocoin
from a succinct pairing-based proof system. In Proceedings of the 2013 Workshop on Language Support
for Privacy Enhancing Technologies, PETShop ’13, 2013. URL: http://www0.cs.ucl.ac.uk/staff/G.
Danezis/papers/DanezisFournetKohlweissParno13.pdf.

[DMS04]

Roger Dingledine, Nick Mathewson, and Paul Syverson. Tor: the second-generation onion router. In
Proceedings of the 13th USENIX Security Symposium, Security ’04, pages 21–21, 2004.

[DW13]

Christian Decker and Roger Wattenhofer. Information propagation in the Bitcoin network. In Proceedings
of the 13th IEEE International Conference on Peer-to-Peer Computing, P2P ’13, pages 1–10, 2013.

[ES13]

Ittay Eyal and Emin Gün Sirer. Majority is not enough: Bitcoin mining is vulnerable, 2013.

[Gen04]

Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure
under concurrent man-in-the-middle attacks. In Proceedings of the 24th Annual International Cryptology
Conference, CRYPTO ’04, pages 220–236, 2004.

[GGPR13]

Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and
succinct NIZKs without PCPs. In Proceedings of the 32nd Annual International Conference on Theory
and Application of Cryptographic Techniques, EUROCRYPT ’13, pages 626–645, 2013.

[GMR89]

Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof
systems. SIAM Journal on Computing, 18(1):186–208, 1989. Preliminary version appeared in STOC ’85.

[GOS06a]

Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive Zaps and new techniques for NIZK. In
Proceedings of the 26th Annual International Conference on Advances in Cryptology, CRYPTO ’06, pages
97–111, 2006.

[GOS06b]

Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In
Proceedings of the 25th Annual International Conference on Advances in Cryptology, EUROCRYPT ’06,
pages 339–358, 2006.

[Gro10]

Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Proceedings of the
16th International Conference on the Theory and Application of Cryptology and Information Security,
ASIACRYPT ’10, pages 321–340, 2010.

[GW11]

Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable
assumptions. In Proceedings of the 43rd Annual ACM Symposium on Theory of Computing, STOC ’11,
pages 99–108, 2011.

[KL07]

Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography. Chapman & Hall/CRC, 2007.

[Lee13]

Timothy B. Lee. Bitcoin needs to scale by a factor of 1000 to compete with Visa. here’s how to do it.
The Washington Post (http://www.washingtonpost.com), November 2013.

[Lip12]

Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography, TCC ’12,
pages 169–189, 2012.

[Lip13]

Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear
error-correcting codes. In Proceedings of the 19th International Conference on the Theory and Application
of Cryptology and Information Security, ASIACRYPT ’13, pages 41–60, 2013.

[Max13]

Greg Maxwell. CoinJoin: Bitcoin privacy for the real world, August 2013. Bitcoin Forum. URL:
https://bitcointalk.org/index.php?topic=279249.0.

[MGGR13] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed
e-cash from bitcoin. In Proceedings of the 2013 IEEE Symposium on Security and Privacy, SP ’13, pages
397–411, 2013.
[Mic00]

Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000.
Preliminary version appeared in FOCS ’94.

[MPJ+ 13]

Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoffrey M.
Voelker, and Stefan Savage. A fistful of Bitcoins: Characterizing payments among men with no names. In
Proceedings of the 2013 Conference on Internet Measurement Conference, IMC ’13, pages 127–140, 2013.

[Nak09]

Satoshi Nakamoto. Bitcoin: a peer-to-peer electronic cash system, 2009. URL: http://www.bitcoin.
org/bitcoin.pdf.

[Nat12]

National Institute of Standards and Technology. FIPS PUB 180-4: Secure Hash Standard. http:
//csrc.nist.gov/publications/PubsFIPS.html, 2012.

55

[PGHR13]

Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: nearly practical verifiable
computation. In Proceedings of the 34th IEEE Symposium on Security and Privacy, Oakland ’13, pages
238–252, 2013.

[Pol13]

PolarSSL. PolarSSL. http://polarssl.org, Oct 2013.

[RM11]

Fergal Reid and Harrigan Martin. An analysis of anonymity in the Bitcoin system. In Proceedings of
the 3rd IEEE International Conference on Privacy, Security, Risk and Trust and on Social Computing,
SocialCom/PASSAT ’11, pages 1318–1326, 2011.

[RS12]

Dorit Ron and Adi Shamir. Quantitative analysis of the full Bitcoin transaction graph. Cryptology
ePrint Archive, Report 2012/584, 2012.

[ST99]

Tomas Sander and Amnon Ta-Shma. Auditable, anonymous electronic cash. In Proceedings of the 19th
Annual International Cryptology Conference on Advances in Cryptology, CRYPTO ’99, pages 555–572,
1999.

[Val08]

Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency.
In Proceedings of the 5th Theory of Cryptography Conference, TCC ’08, pages 1–18, 2008.

[Wui14]

Pieter Wuille. Proposed BIP for dealing with malleability. Available at https://gist.github.com/
sipa/8907691, 2014.

56

